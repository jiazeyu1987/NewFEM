<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NewFEM - Focused Emboli Monitor</title>
    <style>
        /* --- VS Code Theme Variables --- */
        :root {
            --bg-color: #1e1e1e;
            --sidebar-bg: #252526;
            --activity-bar-bg: #333333;
            --text-color: #cccccc;
            --text-highlight: #ffffff;
            --accent-color: #007acc;
            --accent-hover: #0062a3;
            --border-color: #3e3e42;
            --input-bg: #3c3c3c;
            --button-bg: #0e639c;
            --button-hover: #1177bb;
            --success-color: #4ec9b0;
            --warning-color: #dcdcaa;
            --error-color: #f48771;
            --grid-color: #404040;
            --baseline-color: #dcdcaa;
            --chart-line-color: #4ec9b0;
            --panel-header-bg: #303031;
            --status-bar-bg: #007acc;
        }

        /* --- Global Reset & Layout --- */
        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            overflow: hidden;
            font-size: 13px;
        }

        /* --- Sidebar --- */
        .sidebar {
            width: 300px;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .panel {
            border-bottom: 1px solid var(--border-color);
        }

        .panel-header {
            background-color: var(--panel-header-bg);
            padding: 8px 12px;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        
        .panel-content {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* --- UI Components --- */
        .status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
        }

        .status-value {
            color: var(--text-highlight);
            font-family: 'Consolas', 'Courier New', monospace;
        }

        .indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 6px;
        }
        .indicator.connected { background-color: var(--success-color); box-shadow: 0 0 5px var(--success-color); }
        .indicator.disconnected { background-color: var(--error-color); }
        .indicator.connecting { background-color: var(--warning-color); animation: pulse 1s infinite; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        .control-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        button {
            background-color: var(--button-bg);
            color: white;
            border: none;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            border-radius: 2px;
            transition: background 0.2s;
        }
        button:hover:not(:disabled) { background-color: var(--button-hover); }
        button:disabled { background-color: #3a3a3a; color: #888; cursor: not-allowed; }
        button.danger { background-color: #a1260d; }
        button.danger:hover { background-color: #c93312; }

        /* æˆªå–æŒ‰é’®ç‰¹æ®Šæ ·å¼ */
        #capture-btn {
            background: linear-gradient(135deg, #007acc 0%, #005a9e 100%);
            border: 1px solid #005a9e;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        #capture-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #1177bb 0%, #0066aa 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 122, 204, 0.3);
        }

        #capture-btn:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 122, 204, 0.3);
        }

        #capture-btn:disabled {
            background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%);
            border-color: #555;
            cursor: not-allowed;
        }

        /* æˆªå–æˆåŠŸåŠ¨ç”» */
        @keyframes capture-success {
            0% { background: linear-gradient(135deg, #007acc 0%, #005a9e 100%); }
            50% { background: linear-gradient(135deg, #4ec9b0 0%, #3ba58f 100%); }
            100% { background: linear-gradient(135deg, #007acc 0%, #005a9e 100%); }
        }

        #capture-btn.success {
            animation: capture-success 1s ease-in-out;
        }

        /* å­æ³¢å½¢å®¹å™¨æ˜¾ç¤ºåŠ¨ç”» */
        .subwaveform-container {
            height: 200px;
            border-top: 1px solid var(--border-color);
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
        }

        .subwaveform-container.show {
            opacity: 1;
            transform: translateY(0);
        }

        /* æˆªå–ä¿¡æ¯é¢æ¿æ·¡å…¥åŠ¨ç”» */
        #capture-info {
            transition: opacity 0.3s ease, transform 0.3s ease;
            opacity: 0;
            transform: translateY(-10px);
        }

        #capture-info.show {
            opacity: 1;
            transform: translateY(0);
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        .toggle-switch input { display: none; }
        .slider {
            width: 30px;
            height: 16px;
            background-color: #3a3a3a;
            border-radius: 10px;
            position: relative;
            margin-right: 8px;
            transition: .2s;
        }
        .slider:before {
            content: "";
            position: absolute;
            height: 12px;
            width: 12px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            border-radius: 50%;
            transition: .2s;
        }
        input:checked + .slider { background-color: var(--accent-color); }
        input:checked + .slider:before { transform: translateX(14px); }

        .range-slider-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        input[type=range] {
            width: 100%;
            background: transparent;
            -webkit-appearance: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            margin-top: -5px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #3a3a3a;
            border-radius: 2px;
        }

        #roi-canvas {
            background-color: #000;
            border: 1px solid var(--border-color);
            width: 200px;
            height: 150px;
            margin: 0 auto;
            image-rendering: pixelated;
        }

        /* --- Main Content --- */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: #1e1e1e;
            position: relative;
        }

        .chart-toolbar {
            height: 35px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 16px;
            background-color: var(--bg-color);
        }

        .chart-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: crosshair;
        }

        .status-bar {
            height: 22px;
            background-color: var(--status-bar-bg);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 11px;
            justify-content: space-between;
        }

        /* Sub-waveform Styles */
        .subwaveform-container {
            /* ç§»é™¤åˆ°ä¸Šé¢ç»Ÿä¸€å®šä¹‰ */
        }

        .subwaveform-toolbar {
            height: 25px;
            background-color: var(--panel-header-bg);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
        }

        .subwaveform-chart-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: crosshair;
            background-color: #1a1a1a;
        }

        #subwaveform-chart {
            display: block;
            width: 100%;
            height: 100%;
        }

        #subwaveform-tooltip {
            position: absolute;
            background-color: var(--panel-header-bg);
            color: var(--text-highlight);
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            border: 1px solid var(--border-color);
        }

        /* Tooltip */
        #tooltip {
            position: absolute;
            background: rgba(37, 37, 38, 0.9);
            border: 1px solid var(--accent-color);
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 11px;
            pointer-events: none;
            display: none;
            z-index: 100;
        }

        /* Signal indicators */
        .signal-indicator {
            padding: 2px 6px;
            border-radius: 2px;
            font-weight: bold;
        }
        .signal-green { color: var(--success-color); background: rgba(78, 201, 176, 0.1); }
        .signal-red { color: var(--error-color); background: rgba(244, 135, 113, 0.1); }
        .signal-none { color: #666; }

        /* ROI è¾“å…¥æ¡†æ ·å¼ */
        .roi-input {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-family: 'Consolas', 'Courier New', monospace;
            text-align: right;
        }
        .roi-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 1px var(--accent-color);
        }
        .roi-input:invalid {
            border-color: var(--error-color);
        }

    </style>
</head>
<body>

    <!-- SIDEBAR -->
    <div class="sidebar">
        <!-- 1.1 æ§åˆ¶å°é¢æ¿ -->
        <div class="panel">
            <div class="panel-header">æ§åˆ¶å°</div>
            <div class="panel-content">
                <div class="status-row">
                    <span>çŠ¶æ€:</span>
                    <span id="detection-state" style="color:var(--accent-color); font-weight:bold;">IDLE</span>
                </div>
                <div class="control-group">
                    <button id="start-btn">å¼€å§‹æ£€æµ‹</button>
                    <button id="stop-btn" class="danger" disabled>åœæ­¢</button>
                    <button id="pause-btn" disabled>æš‚åœ</button>
                    <button id="resume-btn" disabled>æ¢å¤</button>
                </div>
                <button id="refresh-status-btn" style="width: 100%; margin-top: 5px;">åˆ·æ–°ç³»ç»ŸçŠ¶æ€</button>
            </div>
        </div>

        <!-- 1.2 æ³¢å½¢æˆªå–é¢æ¿ -->
        <div class="panel">
            <div class="panel-header">æ³¢å½¢æˆªå–</div>
            <div class="panel-content">
                <!-- æ•°æ®æºé€‰æ‹© -->
                <div class="status-row">
                    <span>æ•°æ®æº:</span>
                    <div>
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="radio" id="data-source-main" name="data-source" value="main">
                            <span>ä¸»ä¿¡å·æ•°æ®</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; margin-left: 12px;">
                            <input type="radio" id="data-source-roi" name="data-source" value="roi" checked>
                            <span>ROIç°åº¦æ•°æ®</span>
                        </label>
                    </div>
                </div>

                <!-- æˆªå–çª—å£å¤§å°è®¾ç½® -->
                <div class="range-slider-container">
                    <div class="status-row">
                        <span>çª—å£å¤§å°</span>
                        <span id="capture-window-size" class="status-value">100 å¸§</span>
                    </div>
                    <input type="range" id="capture-window-slider" min="50" max="200" step="10" value="100">
                </div>

                <!-- æˆªå–çŠ¶æ€æŒ‡ç¤º -->
                <div class="status-row">
                    <span>æˆªå–çŠ¶æ€:</span>
                    <div>
                        <span id="capture-status-indicator" class="indicator disconnected"></span>
                        <span id="capture-status-text">ç­‰å¾…æˆªå–</span>
                    </div>
                </div>

                <!-- æˆªå–æŒ‰é’® -->
                <button id="capture-btn" style="width: 100%; height: 35px; font-size: 14px; font-weight: 600; margin: 10px 0;">
                    ğŸ“¸ ç«‹å³æˆªå–
                </button>

                <!-- æ³¢å³°é¢œè‰²æŒ‡ç¤ºå™¨ -->
                <div id="peak-indicator" style="display: none; text-align: center; margin: 5px 0; font-size: 14px; font-weight: 600;">
                    <span id="peak-indicator-text" style="padding: 3px 8px; border-radius: 3px;"></span>
                </div>

                <!-- æˆªå–ä¿¡æ¯æ˜¾ç¤º -->
                <div id="capture-info" style="display: none;">
                    <hr style="border: 1px solid var(--border-color); margin: 10px 0;">
                    <div class="status-row">
                        <span>æ•°æ®ç±»å‹:</span>
                        <span id="captured-data-type" class="status-value">ROIç°åº¦æ•°æ®</span>
                    </div>
                    <div class="status-row">
                        <span>æˆªå–å¸§æ•°:</span>
                        <span id="captured-frame-count" class="status-value">0</span>
                    </div>
                    <div class="status-row">
                        <span>å¸§èŒƒå›´:</span>
                        <span id="captured-frame-range" class="status-value">0-0</span>
                    </div>
                    <div class="status-row">
                        <span>æŒç»­æ—¶é—´:</span>
                        <span id="captured-duration" class="status-value">0.00s</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 3.3 ROI å›¾åƒæ˜¾ç¤º -->
        <div class="panel">
            <div class="panel-header">ROI ç›‘æ§</div>
            <div class="panel-content" style="align-items: center;">
                <canvas id="roi-canvas" width="200" height="150"></canvas>
                <div class="status-row" style="width: 100%">
                    <span>ROI å¹³å‡ç°åº¦:</span>
                    <span id="roi-gray-value" class="status-value">0.0</span>
                </div>
            </div>
        </div>

        <!-- 3.4 ROI è®¾ç½®é¢æ¿ -->
        <div class="panel">
            <div class="panel-header">ROI è®¾ç½®</div>
            <div class="panel-content">
                <!-- ROIé…ç½®çŠ¶æ€æŒ‡ç¤º -->
                <div class="status-row">
                    <span>é…ç½®çŠ¶æ€:</span>
                    <div>
                        <span id="roi-status-indicator" class="indicator disconnected"></span>
                        <span id="roi-status-text">æœªé…ç½®</span>
                    </div>
                </div>
                <div class="status-row">
                    <span>x1 åæ ‡:</span>
                    <input type="number" id="roi-x1" class="roi-input" value="0" min="0" style="width: 80px;">
                </div>
                <div class="status-row">
                    <span>y1 åæ ‡:</span>
                    <input type="number" id="roi-y1" class="roi-input" value="0" min="0" style="width: 80px;">
                </div>
                <div class="status-row">
                    <span>x2 åæ ‡:</span>
                    <input type="number" id="roi-x2" class="roi-input" value="200" min="0" style="width: 80px;">
                </div>
                <div class="status-row">
                    <span>y2 åæ ‡:</span>
                    <input type="number" id="roi-y2" class="roi-input" value="150" min="0" style="width: 80px;">
                </div>
                <hr style="border: 1px solid var(--border-color); margin: 10px 0;">
                <div class="status-row">
                    <span>ä¸­å¿ƒç‚¹:</span>
                    <span id="roi-center" class="status-value">(100, 75)</span>
                </div>
                <div class="status-row">
                    <span>å®½åº¦:</span>
                    <span id="roi-width" class="status-value">200 px</span>
                </div>
                <div class="status-row">
                    <span>é«˜åº¦:</span>
                    <span id="roi-height" class="status-value">150 px</span>
                </div>
                <div class="status-row">
                    <span>å¸§ç‡è®¾ç½®:</span>
                    <input type="number" id="roi-frame-rate" class="roi-input" value="2" min="1" max="60" style="width: 80px;">
                    <span class="status-value" id="roi-fps-display">2 FPS</span>
                </div>
                <div class="control-group" style="margin-top: 10px;">
                    <button id="apply-roi-btn" style="width: 100%; height: 30px; font-size: 12px;">åº”ç”¨é…ç½®</button>
                </div>
            </div>
        </div>

        
        <!-- 3.6 æ³¢å³°æ£€æµ‹é…ç½®é¢æ¿ -->
        <div class="panel">
            <div class="panel-header">æ³¢å³°æ£€æµ‹è®¾ç½®</div>
            <div class="panel-content">
                <!-- ç»å¯¹é˜ˆå€¼ -->
                <div class="status-row">
                    <span>ç»å¯¹é˜ˆå€¼:</span>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="number" id="peak-threshold" class="roi-input" value="105" min="50" max="255" step="0.1" style="width: 80px;">
                        <span class="status-value">ç°åº¦å€¼ â‰¥ é˜ˆå€¼è§¦å‘æ³¢å³°</span>
                    </div>
                </div>

                <!-- è¾¹ç•Œæ‰©å±•å¸§æ•° -->
                <div class="status-row">
                    <span>è¾¹ç•Œæ‰©å±•:</span>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="number" id="peak-margin-frames" class="roi-input" value="5" min="1" max="20" style="width: 80px;">
                        <span class="status-value">æ³¢å³°åŒºåŸŸå‰åæ‰©å±•å¸§æ•°</span>
                    </div>
                </div>

                <!-- é¢œè‰²åˆ†ç±»é˜ˆå€¼ -->
                <div class="status-row">
                    <span>åˆ†ç±»é˜ˆå€¼:</span>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="number" id="peak-difference-threshold" class="roi-input" value="2.1" min="0.1" max="10" step="0.1" style="width: 80px;">
                        <span class="status-value">
                            <span style="color: #4ec9b0;">ğŸŸ¢</span> å·®å€¼>é˜ˆå€¼
                            <span style="color: #f44747;">ğŸ”´</span> å·®å€¼â‰¤é˜ˆå€¼
                        </span>
                    </div>
                </div>

                <!-- æœ€å°åŒºåŸŸé•¿åº¦ -->
                <div class="status-row">
                    <span>æœ€å°åŒºåŸŸ:</span>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="number" id="peak-min-region-length" class="roi-input" value="3" min="1" max="20" style="width: 80px;">
                        <span class="status-value">æœ€å°æ³¢å³°åŒºåŸŸé•¿åº¦ï¼ˆå¸§ï¼‰</span>
                    </div>
                </div>

                <hr style="border: 1px solid var(--border-color); margin: 10px 0;">

                <!-- æ³¢å³°æ£€æµ‹çŠ¶æ€ -->
                <div class="status-row">
                    <span>æ£€æµ‹çŠ¶æ€:</span>
                    <div>
                        <span id="peak-status-indicator" class="indicator disconnected"></span>
                        <span id="peak-status-text">æœªæ¿€æ´»</span>
                    </div>
                </div>

                <div class="status-row">
                    <span>å½“å‰é¢œè‰²:</span>
                    <div id="current-peak-color" style="display: flex; align-items: center; gap: 5px;">
                        <span class="status-value">-</span>
                    </div>
                </div>

                <div class="control-group" style="margin-top: 10px;">
                    <button id="apply-peak-config-btn" style="width: 100%; height: 30px; font-size: 12px;">åº”ç”¨æ³¢å³°é…ç½®</button>
                </div>
            </div>
        </div>

      
        <!-- ç³»ç»ŸçŠ¶æ€é¢æ¿ - å·²éšè— -->
        <div class="panel" style="display: none;">
            <div class="panel-header">ç³»ç»ŸçŠ¶æ€</div>
            <div class="panel-content" style="display: none;">
                <div class="status-row">
                    <span>è¿æ¥çŠ¶æ€</span>
                    <div>
                        <span id="connection-indicator" class="indicator disconnected"></span>
                        <span id="connection-text">Disconnected</span>
                    </div>
                </div>
                <div class="status-row">
                    <span>å¸§æ•°è®¡æ•°</span>
                    <span id="frame-count" class="status-value">0</span>
                </div>
                <div class="status-row">
                    <span>å½“å‰å€¼</span>
                    <span id="current-value" class="status-value">0.00</span>
                </div>
                <div class="status-row">
                    <span>åŸºçº¿å€¼</span>
                    <span id="baseline-value" class="status-value">0.00</span>
                </div>
                <div class="status-row">
                    <span>æ³¢å³°ä¿¡å·</span>
                    <span id="peak-signal" class="status-value signal-none">NULL</span>
                </div>
                 <div class="status-row">
                    <span>ç¼“å†²åŒº</span>
                    <span id="buffer-size" class="status-value">0</span>
                </div>
                <div class="status-row">
                    <span>FPS</span>
                    <span id="update-rate" class="status-value">0 Hz</span>
                </div>
            </div>
        </div>

        <!-- æ˜¾ç¤ºæ§åˆ¶é¢æ¿ - å·²éšè— -->
        <div class="panel" style="display: none;">
            <div class="panel-header">æ˜¾ç¤ºæ§åˆ¶</div>
            <div class="panel-content" style="display: none;">
                <label class="toggle-switch">
                    <input type="checkbox" id="show-grid" checked>
                    <div class="slider"></div>
                    <span>æ˜¾ç¤ºç½‘æ ¼</span>
                </label>
                <label class="toggle-switch">
                    <input type="checkbox" id="show-baseline" checked>
                    <div class="slider"></div>
                    <span>æ˜¾ç¤ºåŸºçº¿</span>
                </label>
                <label class="toggle-switch">
                    <input type="checkbox" id="show-points" checked>
                    <div class="slider"></div>
                    <span>æ˜¾ç¤ºæ•°æ®ç‚¹</span>
                </label>

                <div class="range-slider-container">
                    <div class="status-row">
                        <span>Yè½´ç¼©æ”¾</span>
                        <span id="zoom-value" class="status-value">1.0x</span>
                    </div>
                    <input type="range" id="zoom-slider" min="0.5" max="3.0" step="0.1" value="1.0">
                </div>
            </div>
        </div>
    </div>

    <!-- MAIN CONTENT -->
    <div class="main-content">
        <div class="chart-toolbar">
            <span style="font-weight: 600; font-size: 12px;">å®æ—¶ç°åº¦æ³¢å½¢å›¾ (Real-time Waveform)</span>
        </div>
        
        <div class="chart-container" id="chart-container">
            <canvas id="waveform-chart"></canvas>
            <div id="tooltip"></div>
        </div>

        <!-- å­æ³¢å½¢æ˜¾ç¤ºåŒºåŸŸ -->
        <div class="subwaveform-container" id="subwaveform-container" style="display: none;">
            <div class="subwaveform-toolbar">
                <span style="font-weight: 600; font-size: 12px;">æˆªå–æ³¢å½¢ (Captured Waveform)</span>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button id="clear-subwaveform-btn" style="height: 20px; font-size: 10px; padding: 0 8px;">æ¸…é™¤</button>
                    <span id="subwaveform-info" style="font-size: 10px; color: var(--text-highlight);"></span>
                </div>
            </div>
            <div class="subwaveform-chart-container">
                <canvas id="subwaveform-chart"></canvas>
                <div id="subwaveform-tooltip"></div>
            </div>
        </div>

        <div class="status-bar">
            <span id="chart-status">Ready</span>
            <span id="last-update">Last Update: --:--:--</span>
        </div>
    </div>

    <!-- JAVASCRIPT LOGIC -->
    <script>
        /**
         * 1. å…¨å±€çŠ¶æ€ç®¡ç† (appState)
         * å¯¹åº”éœ€æ±‚ 4.1
         */
        const appState = {
            connected: false,
            serverUrl: 'http://localhost:8421', // å®é™…ç¯å¢ƒåœ°å€
            chartData: [],         // æ ¼å¼: {t: number, value: number}[]
            roiData: null,
            frameCount: 0,
            currentValue: 0,
            peakSignal: null,      // 1 (Green), 0 (Red), null
            baseline: 120,
            updateRate: 20,
            detectionState: 'IDLE', // IDLE, RUNNING, PAUSED, STOPPED
            chartState: {
                showGrid: true,
                showBaseline: true,
                showPoints: true,
                zoom: 1.0,
                offsetY: 0
            },
            // ROIé…ç½®çŠ¶æ€
            roiConfig: {
                x1: 0,
                y1: 0,
                x2: 200,
                y2: 150,
                center_x: 100,
                center_y: 75,
                width: 200,
                height: 150
            },
            roiConfigured: false,  // ROIæ˜¯å¦å·²ç”±ç”¨æˆ·é…ç½®
            // ROIæ›´æ–°é¢‘ç‡æ§åˆ¶
            roiUpdateInterval: 500,  // ROIæ›´æ–°é—´éš”ï¼ˆæ¯«ç§’ï¼‰
            lastRoiUpdate: 0,        // ä¸Šæ¬¡ROIæ›´æ–°æ—¶é—´
            roiFrameRate: 2,         // ROIå¸§ç‡ï¼ˆFPSï¼‰
            // æ³¢å³°æ£€æµ‹é…ç½®
            peakConfig: {
                threshold: 105.0,
                margin_frames: 5,
                difference_threshold: 2.1,
                min_region_length: 3
            },
            // å†…éƒ¨ä½¿ç”¨çš„é…ç½®
            maxDataPoints: 100,
            pollingIntervals: {
                realtime: null,
                status: null
            }
        };

  
        /**
         * 3. APIé€šä¿¡å±‚ (API Service)
         */
        const ApiService = {
            async fetchRealtimeData() {
                try {
                    // æ ¹æ®ROIé…ç½®çŠ¶æ€å†³å®šè¯·æ±‚æ•°æ®é‡
                    const count = appState.roiConfigured ? 1 : 5;
                    const response = await fetch(`${appState.serverUrl}/data/realtime?count=${count}`);
                    if(!response.ok) throw new Error('Network response was not ok');
                    return await response.json();
                } catch(e) {
                    console.error("Fetch Error", e);
                    return null;
                }
            },

            async sendControl(command) {
                  const formData = new URLSearchParams();
                formData.append('command', command);
                formData.append('password', '31415'); // ç¡¬ç¼–ç å¯†ç 

                try {
                    const response = await fetch(`${appState.serverUrl}/control`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        body: formData
                    });
                    return await response.json();
                } catch(e) {
                    return { status: 'error' };
                }
            },

            // ROIç›¸å…³API
            async getRoiConfig() {
                try {
                    const response = await fetch(`${appState.serverUrl}/roi/config`);
                    if (!response.ok) throw new Error('Network response was not ok');
                    return await response.json();
                } catch(e) {
                    console.error("Get ROI config error:", e);
                    return null;
                }
            },

            async setRoiConfig(x1, y1, x2, y2) {
                const formData = new URLSearchParams();
                formData.append('x1', x1);
                formData.append('y1', y1);
                formData.append('x2', x2);
                formData.append('y2', y2);
                formData.append('password', '31415');

                try {
                    const response = await fetch(`${appState.serverUrl}/roi/config`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        body: formData
                    });
                    if (!response.ok) throw new Error('Network response was not ok');
                    return await response.json();
                } catch(e) {
                    console.error("Set ROI config error:", e);
                    return { success: false, error: String(e) };
                }
            },

            async getRoiFrameRate() {
                try {
                    const response = await fetch(`${appState.serverUrl}/roi/frame-rate`);
                    if (!response.ok) throw new Error('Network response was not ok');
                    return await response.json();
                } catch(e) {
                    console.error("Get ROI frame rate error:", e);
                    return null;
                }
            },

            async setRoiFrameRate(frameRate) {
                const formData = new URLSearchParams();
                formData.append('frame_rate', frameRate);
                formData.append('password', '31415');

                try {
                    const response = await fetch(`${appState.serverUrl}/roi/frame-rate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        body: formData
                    });
                    if (!response.ok) throw new Error('Network response was not ok');
                    return await response.json();
                } catch(e) {
                    console.error("Set ROI frame rate error:", e);
                    return { success: false, error: String(e) };
                }
            },

            // æ³¢å³°æ£€æµ‹é…ç½®API
            async getPeakDetectionConfig() {
                try {
                    const response = await fetch(`${appState.serverUrl}/peak-detection/config`);
                    if (!response.ok) throw new Error('Network response was not ok');
                    return await response.json();
                } catch(e) {
                    console.error("Get peak detection config error:", e);
                    return { success: false, error: e.message };
                }
            },

            async setPeakDetectionConfig(config) {
                const formData = new URLSearchParams();
                if (config.threshold !== undefined) formData.append('threshold', config.threshold);
                if (config.margin_frames !== undefined) formData.append('margin_frames', config.margin_frames);
                if (config.difference_threshold !== undefined) formData.append('difference_threshold', config.difference_threshold);
                if (config.min_region_length !== undefined) formData.append('min_region_length', config.min_region_length);
                formData.append('password', '31415');

                try {
                    const response = await fetch(`${appState.serverUrl}/peak-detection/config`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        body: formData
                    });
                    if (!response.ok) throw new Error('Network response was not ok');
                    return await response.json();
                } catch(e) {
                    console.error("Set peak detection config error:", e);
                    return { success: false, error: e.message };
                }
            },

            // çª—å£æˆªå–API
            async captureWindow(count = 100) {
                try {
                    const response = await fetch(`${appState.serverUrl}/data/window-capture?count=${count}`);
                    if (!response.ok) throw new Error('Network response was not ok');
                    return await response.json();
                } catch(e) {
                    console.error("Window capture error:", e);
                    return { success: false, error: e.message };
                }
            },

            // ROIçª—å£æˆªå–API
            async captureRoiWindow(count = 100) {
                try {
                    const response = await fetch(`${appState.serverUrl}/data/roi-window-capture?count=${count}`);
                    if (!response.ok) throw new Error('Network response was not ok');
                    return await response.json();
                } catch(e) {
                    console.error("ROI window capture error:", e);
                    return { success: false, error: e.message };
                }
            },

            // ROIçª—å£æˆªå–å¸¦æ³¢å³°æ£€æµ‹API
            async captureRoiWindowWithPeaks(count = 100, threshold = null, marginFrames = null, differenceThreshold = null) {
                try {
                    const url = `${appState.serverUrl}/data/roi-window-capture-with-peaks?count=${count}&threshold=${threshold}&margin_frames=${marginFrames}&difference_threshold=${differenceThreshold}`;
                    console.log(`ğŸ” è¯·æ±‚ROIçª—å£æ³¢å³°æ£€æµ‹: ${url}`);
                    const response = await fetch(url);
                    if (!response.ok) throw new Error('Network response was not ok');
                    const data = await response.json();
                    console.log('ğŸ“Š ROIçª—å£æ³¢å³°æ£€æµ‹å“åº”:', data);

                    // æ‰“å°æ³¢å³°æ£€æµ‹ç»“æœåˆ°æ§åˆ¶å°
                    if (data.peak_detection_results) {
                        console.log('\n=== ğŸ¯ ROIçª—å£æ³¢å³°æ£€æµ‹ç»“æœ ===');
                        const results = data.peak_detection_results;
                        if (results.error) {
                            console.error('âŒ æ³¢å³°æ£€æµ‹å¤±è´¥:', results.error);
                        } else {
                            console.log(`âœ… æ£€æµ‹å®Œæˆ - æ€»è®¡: ${results.total_peaks} ä¸ªæ³¢å³°`);
                            console.log(`ğŸŸ¢ ç»¿è‰²æ³¢å³° (ç¨³å®š): ${results.green_peak_count} ä¸ª:`, results.green_peaks);
                            console.log(`ğŸ”´ çº¢è‰²æ³¢å³° (ä¸ç¨³å®š): ${results.red_peak_count} ä¸ª:`, results.red_peaks);

                            // è¯¦ç»†æ‰“å°æ¯ä¸ªæ³¢å³°ä¿¡æ¯
                            if (results.green_peaks.length > 0) {
                                console.log('ğŸŸ¢ ç»¿è‰²æ³¢å³°è¯¦ç»†ä¿¡æ¯:');
                                results.green_peaks.forEach((peak, index) => {
                                    console.log(`   ${index + 1}. å¸§èŒƒå›´: ${peak[0]} - ${peak[1]} (æŒç»­ ${peak[1] - peak[0] + 1} å¸§)`);
                                });
                            }

                            if (results.red_peaks.length > 0) {
                                console.log('ğŸ”´ çº¢è‰²æ³¢å³°è¯¦ç»†ä¿¡æ¯:');
                                results.red_peaks.forEach((peak, index) => {
                                    console.log(`   ${index + 1}. å¸§èŒƒå›´: ${peak[0]} - ${peak[1]} (æŒç»­ ${peak[1] - peak[0] + 1} å¸§)`);
                                });
                            }
                        }
                        console.log('=== æ³¢å³°æ£€æµ‹ç»“æŸ ===\n');
                    }

                    return data;
                } catch(e) {
                    console.error("ROI window capture with peaks error:", e);
                    return { success: false, error: e.message };
                }
            }
        };

        /**
         * 4. æ¸²æŸ“å¼•æ“ (Chart & ROI)
         */
        class WaveformChart {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d', { alpha: false }); // ä¼˜åŒ–æ€§èƒ½
                this.container = document.getElementById('chart-container');
                this.tooltip = document.getElementById('tooltip');
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                // æ»šè½®ç¼©æ”¾
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = Math.sign(e.deltaY) * -0.1;
                    let newZoom = Math.max(0.5, Math.min(3.0, appState.chartState.zoom + delta));
                    appState.chartState.zoom = parseFloat(newZoom.toFixed(1));
                    document.getElementById('zoom-slider').value = appState.chartState.zoom;
                    document.getElementById('zoom-value').innerText = appState.chartState.zoom + 'x';
                    this.draw();
                });

                // é¼ æ ‡äº¤äº’
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseleave', () => { this.tooltip.style.display = 'none'; });
            }

            resize() {
                const rect = this.container.getBoundingClientRect();
                // å¤„ç† DPI
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.canvas.style.width = `${rect.width}px`;
                this.canvas.style.height = `${rect.height}px`;
                this.width = rect.width;
                this.height = rect.height;
                this.draw();
            }

            draw() {
                if (!this.ctx) return;
                
                const { width, height } = this;
                const { showGrid, showBaseline, showPoints, zoom } = appState.chartState;
                const data = appState.chartData;

                // 1. æ¸…ç©ºèƒŒæ™¯
                this.ctx.fillStyle = '#1e1e1e';
                this.ctx.fillRect(0, 0, width, height);

                // Yè½´ æ˜ å°„å‡½æ•°: å°† 0-255 æ˜ å°„åˆ° Canvas é«˜åº¦
                // æ”¾å¤§æ—¶å›´ç»•ä¸­å¿ƒç‚¹ (128) æ”¾å¤§
                const midY = height / 2;
                const scaleY = (height / 255) * zoom; 
                const mapY = (val) => midY - (val - 128) * scaleY; // ç¿»è½¬Yè½´ï¼Œå¤§å€¼åœ¨ä¸Šæ–¹

                // 2. ç»˜åˆ¶ç½‘æ ¼
                if (showGrid) {
                    this.ctx.strokeStyle = '#333';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    // ç®€å•çš„æ°´å¹³ç½‘æ ¼
                    for (let v = 0; v <= 255; v += 50) {
                        const y = mapY(v);
                        this.ctx.moveTo(0, y);
                        this.ctx.lineTo(width, y);
                    }
                    // ç®€å•çš„å‚ç›´ç½‘æ ¼
                    const step = width / 10;
                    for (let x = 0; x < width; x += step) {
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, height);
                    }
                    this.ctx.stroke();
                }

                if (data.length === 0) return;

                // Xè½´ æ­¥è¿›
                const stepX = width / (appState.maxDataPoints - 1);

                // 3. ç»˜åˆ¶åŸºçº¿
                if (showBaseline) {
                    const yBase = mapY(appState.baseline);
                    this.ctx.strokeStyle = '#dcdcaa'; // VS Code Warning Color
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, yBase);
                    this.ctx.lineTo(width, yBase);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }

                // 4. ç»˜åˆ¶æ³¢å½¢
                this.ctx.strokeStyle = '#4ec9b0'; // VS Code Success/Type Color
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                data.forEach((pt, i) => {
                    const x = i * stepX;
                    const y = mapY(pt.value);
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                });
                this.ctx.stroke();

                // 5. ç»˜åˆ¶æ•°æ®ç‚¹
                if (showPoints) {
                    this.ctx.fillStyle = '#fff';
                    data.forEach((pt, i) => {
                        const x = i * stepX;
                        const y = mapY(pt.value);
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    });
                }
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                
                const stepX = this.width / (appState.maxDataPoints - 1);
                const index = Math.round(mouseX / stepX);

                if (index >= 0 && index < appState.chartData.length) {
                    const pt = appState.chartData[index];
                    this.tooltip.style.display = 'block';
                    this.tooltip.style.left = (e.clientX + 10) + 'px';
                    this.tooltip.style.top = (e.clientY + 10) + 'px';
                    this.tooltip.innerHTML = `T: ${pt.t.toFixed(2)}s<br>Val: ${pt.value.toFixed(1)}`;
                } else {
                    this.tooltip.style.display = 'none';
                }
            }
        }

        /**
         * æ³¢å½¢æˆªå–åŠŸèƒ½ç±»
         */
        class WaveformCapture {
            constructor() {
                this.capturedData = null;
                this.captureSettings = {
                    windowSize: 100,
                    minSize: 50,
                    maxSize: 200,
                    dataSource: 'roi' // é»˜è®¤ä½¿ç”¨ ROI ç°åº¦æ•°æ®
                };

                console.log('WaveformCapture: Initializing with settings', this.captureSettings);

                this.initElements();
                this.initEventListeners();
                this.initSubWaveformChart();

                // ç¡®ä¿åˆå§‹æ˜¾ç¤ºæ­£ç¡®
                this.syncInitialDisplay();
            }

            syncInitialDisplay() {
                // ç¡®ä¿æ»‘å—å’Œæ˜¾ç¤ºæ–‡æœ¬åˆå§‹çŠ¶æ€æ­£ç¡®
                if (this.elements.windowSlider && this.elements.windowSize) {
                    // ç¡®ä¿æ»‘å—å€¼æ­£ç¡®
                    this.elements.windowSlider.value = this.captureSettings.windowSize;
                    // æ›´æ–°æ˜¾ç¤ºæ–‡æœ¬
                    this.elements.windowSize.textContent = `${this.captureSettings.windowSize} å¸§`;
                    console.log(`WaveformCapture: Initial display synced to ${this.captureSettings.windowSize} frames`);
                }
            }

            initElements() {
                this.elements = {
                    // æˆªå–æ§åˆ¶é¢æ¿
                    windowSlider: document.getElementById('capture-window-slider'),
                    windowSize: document.getElementById('capture-window-size'),
                    captureBtn: document.getElementById('capture-btn'),
                    statusIndicator: document.getElementById('capture-status-indicator'),
                    statusText: document.getElementById('capture-status-text'),

                    // æ•°æ®æºé€‰æ‹©
                    dataSourceMain: document.getElementById('data-source-main'),
                    dataSourceRoi: document.getElementById('data-source-roi'),

                    // æˆªå–ä¿¡æ¯æ˜¾ç¤º
                    infoPanel: document.getElementById('capture-info'),
                    frameCount: document.getElementById('captured-frame-count'),
                    frameRange: document.getElementById('captured-frame-range'),
                    duration: document.getElementById('captured-duration'),
                    dataType: document.getElementById('captured-data-type'),

                    // å­æ³¢å½¢æ˜¾ç¤º
                    container: document.getElementById('subwaveform-container'),
                    info: document.getElementById('subwaveform-info'),
                    clearBtn: document.getElementById('clear-subwaveform-btn')
                };

                // é»˜è®¤ä½¿ç”¨ ROI ä½œä¸ºæˆªå–æ•°æ®æº
                if (this.elements.dataSourceMain && this.elements.dataSourceRoi) {
                    this.elements.dataSourceMain.checked = false;
                    this.elements.dataSourceRoi.checked = true;
                }
                if (this.elements.dataType) {
                    this.elements.dataType.textContent = 'ROIç°åº¦æ•°æ®';
                }
            }

            initEventListeners() {
                // éªŒè¯å…ƒç´ æ˜¯å¦æ­£ç¡®è·å–
                if (!this.elements.windowSlider) {
                    console.error('WaveformCapture: Window slider element not found');
                    return;
                }
                if (!this.elements.windowSize) {
                    console.error('WaveformCapture: Window size display element not found');
                    return;
                }

                console.log('WaveformCapture: Initializing event listeners');

                // çª—å£å¤§å°æ»‘å—
                this.elements.windowSlider.addEventListener('input', (e) => {
                    const newValue = parseInt(e.target.value);
                    this.captureSettings.windowSize = newValue;
                    this.elements.windowSize.textContent = `${newValue} å¸§`;
                    console.log(`WaveformCapture: Window size changed to ${newValue} frames`);
                });

                // æ•°æ®æºé€‰æ‹©
                this.elements.dataSourceMain.addEventListener('change', () => {
                    if (this.elements.dataSourceMain.checked) {
                        this.captureSettings.dataSource = 'main';
                        this.elements.dataType.textContent = 'ä¸»ä¿¡å·æ•°æ®';
                        console.log('WaveformCapture: Data source changed to main signal data');
                    }
                });

                this.elements.dataSourceRoi.addEventListener('change', () => {
                    if (this.elements.dataSourceRoi.checked) {
                        this.captureSettings.dataSource = 'roi';
                        this.elements.dataType.textContent = 'ROIç°åº¦æ•°æ®';
                        console.log('WaveformCapture: Data source changed to ROI gray data');
                    }
                });

                // æˆªå–æŒ‰é’®
                this.elements.captureBtn.addEventListener('click', () => {
                    this.captureWaveform();
                });

                // æ¸…é™¤æŒ‰é’®
                this.elements.clearBtn.addEventListener('click', () => {
                    this.clearCapture();
                });

                console.log('WaveformCapture: Event listeners initialized successfully');
            }

            initSubWaveformChart() {
                // åˆ›å»ºå­æ³¢å½¢å›¾è¡¨å®ä¾‹
                this.subWaveformChart = new SubWaveformChart('subwaveform-chart');
            }

            updateStatus(status, text) {
                this.elements.statusIndicator.className = `indicator ${status}`;
                this.elements.statusText.textContent = text;
            }

            async captureWaveform() {
                try {
                    const dataSource = this.captureSettings.dataSource;

                    // ROI æˆªå–éœ€è¦å…ˆå®Œæˆ ROI é…ç½®
                    if (dataSource === 'roi' && !appState.roiConfigured) {
                        alert('è¯·å…ˆé…ç½® ROI åŒºåŸŸå¹¶è¿è¡Œæ£€æµ‹ï¼Œå†è¿›è¡Œæˆªå–ã€‚');
                        return;
                    }

                    this.updateStatus('connecting', 'æˆªå–ä¸­...');
                    this.elements.captureBtn.disabled = true;

                    let response;
                    if (dataSource === 'roi') {
                        // ä½¿ç”¨å¸¦æ³¢å³°æ£€æµ‹çš„ROIæˆªå–API
                        console.log('ğŸ¯ å¼€å§‹ROIçª—å£æˆªå–å¹¶æ‰§è¡Œæ³¢å³°æ£€æµ‹...');
                        const currentConfig = appState.peakConfig;
                        response = await ApiService.captureRoiWindowWithPeaks(
                            this.captureSettings.windowSize,
                            currentConfig?.threshold || 105.0,  // ä½¿ç”¨é…ç½®å€¼
                            currentConfig?.margin_frames || 5,      // ä½¿ç”¨é…ç½®å€¼
                            currentConfig?.difference_threshold || 2.1     // ä½¿ç”¨é…ç½®å€¼
                        );
                    } else {
                        response = await ApiService.captureWindow(this.captureSettings.windowSize);
                    }

                    if (response && response.success) {
                        this.capturedData = response;
                        this.displayCapturedData(response);

                        // æ ¹æ®æ•°æ®æºæ ¼å¼åŒ–æ—¶é—´åºåˆ—æ•°æ®
                        let series = response.series;
                        if (dataSource === 'roi') {
                            // ROIæ•°æ®ä½¿ç”¨ gray_value å­—æ®µ
                            series = response.series.map(pt => ({
                                t: pt.t,
                                value: pt.gray_value
                            }));
                        }

                        this.showSubWaveform(series);
                        this.updateStatus('connected', 'æˆªå–æˆåŠŸ');

                        // æ·»åŠ æˆåŠŸè§†è§‰åé¦ˆ
                        this.addSuccessFeedback();

                        console.log(`${dataSource === 'roi' ? 'ROI' : 'ä¸»ä¿¡å·'}æ•°æ®æˆªå–æˆåŠŸ:`, response);
                    } else {
                        throw new Error(response?.error || 'æˆªå–å¤±è´¥');
                    }
                } catch (error) {
                    console.error('æ³¢å½¢æˆªå–å¤±è´¥:', error);
                    this.updateStatus('disconnected', 'æˆªå–å¤±è´¥');
                    alert('æ³¢å½¢æˆªå–å¤±è´¥: ' + error.message);
                } finally {
                    this.elements.captureBtn.disabled = false;
                }
            }

            displayCapturedData(data) {
                // æ˜¾ç¤ºæˆªå–ä¿¡æ¯é¢æ¿ - æ·»åŠ åŠ¨ç”»
                this.elements.infoPanel.style.display = 'block';
                // è§¦å‘é‡æ’ä»¥åº”ç”¨åŠ¨ç”»
                setTimeout(() => {
                    this.elements.infoPanel.classList.add('show');
                }, 10);

                const dataSource = this.captureSettings.dataSource;

                // æ›´æ–°ä¿¡æ¯
                this.elements.frameCount.textContent = data.series.length;

                if (dataSource === 'roi') {
                    // ROIæ•°æ®ç‰¹æœ‰çš„ä¿¡æ¯æ˜¾ç¤º
                    this.elements.frameRange.textContent = `ROIå¸§: ${data.roi_frame_range[0]}-${data.roi_frame_range[1]}`;
                    const duration = data.capture_metadata?.capture_duration || 0;
                    this.elements.duration.textContent = `${duration.toFixed(2)}s`;

                    // ROIæ•°æ®ä½¿ç”¨ gray_value å­—æ®µ
                    const values = data.series.map(pt => pt.gray_value);
                    const minValue = Math.min(...values);
                    const maxValue = Math.max(...values);
                    const avgValue = values.reduce((a, b) => a + b, 0) / values.length;
                    const valueRange = maxValue - minValue;

                    // åŸºç¡€ä¿¡æ¯æ–‡æœ¬
                    let infoText = `${data.series.length} ROIå¸§ | ${duration.toFixed(2)}s | ç°åº¦èŒƒå›´: ${minValue.toFixed(0)}-${maxValue.toFixed(0)}`;

                    // æ·»åŠ æ³¢å³°æ£€æµ‹ä¿¡æ¯
                    if (data.peak_detection_results && !data.peak_detection_results.error) {
                        const results = data.peak_detection_results;
                        infoText += ` | ğŸ¯æ³¢å³°: ${results.total_peaks}ä¸ª(ğŸŸ¢${results.green_peak_count} ğŸ”´${results.red_peak_count})`;

                        // æ˜¾ç¤ºæ³¢å³°é¢œè‰²æŒ‡ç¤ºå™¨
                        this.updatePeakIndicator(results);
                    } else {
                        // æ²¡æœ‰æ³¢å³°æ£€æµ‹ç»“æœæ—¶æ˜¾ç¤º0
                        this.updatePeakIndicator(null);
                    }

                    // æ›´æ–°å­æ³¢å½¢ä¿¡æ¯ï¼ŒåŒ…å«ç»Ÿè®¡å’Œæ³¢å³°æ£€æµ‹
                    this.elements.info.textContent = infoText;

                    console.log(`WaveformCapture: Displaying captured ROI data summary:`);
                    console.log(`  - ROI Frames: ${data.series.length}`);
                    console.log(`  - ROI Frame range: ${data.roi_frame_range[0]}-${data.roi_frame_range[1]}`);
                    console.log(`  - Main Frame range: ${data.main_frame_range[0]}-${data.main_frame_range[1]}`);
                    console.log(`  - Duration: ${duration.toFixed(2)}s`);
                    console.log(`  - Gray value range: ${minValue.toFixed(1)} - ${maxValue.toFixed(1)} (span: ${valueRange.toFixed(1)})`);
                    console.log(`  - Average gray value: ${avgValue.toFixed(1)}`);

                    // æ˜¾ç¤ºæ³¢å³°æ£€æµ‹ç»“æœ
                    if (data.peak_detection_results) {
                        console.log(`  - ğŸ¯ Peak Detection Results:`);
                        if (data.peak_detection_results.error) {
                            console.log(`    âŒ Error: ${data.peak_detection_results.error}`);
                        } else {
                            console.log(`    âœ… Total peaks: ${data.peak_detection_results.total_peaks}`);
                            console.log(`    ğŸŸ¢ Green peaks (stable): ${data.peak_detection_results.green_peak_count}`);
                            console.log(`    ğŸ”´ Red peaks (unstable): ${data.peak_detection_results.red_peak_count}`);
                            console.log(`    ğŸ“ Green peak ranges:`, data.peak_detection_results.green_peaks);
                            console.log(`    ğŸ“ Red peak ranges:`, data.peak_detection_results.red_peaks);
                        }
                    }

                } else {
                    // ä¸»ä¿¡å·æ•°æ®ä¿¡æ¯æ˜¾ç¤º
                    this.elements.frameRange.textContent = `${data.frame_range[0]}-${data.frame_range[1]}`;
                    const duration = data.capture_metadata?.duration || 0;
                    this.elements.duration.textContent = `${duration.toFixed(2)}s`;

                    const values = data.series.map(pt => pt.value);
                    const minValue = Math.min(...values);
                    const maxValue = Math.max(...values);
                    const avgValue = values.reduce((a, b) => a + b, 0) / values.length;
                    const valueRange = maxValue - minValue;

                    // æ›´æ–°å­æ³¢å½¢ä¿¡æ¯ï¼ŒåŒ…å«ç»Ÿè®¡
                    this.elements.info.textContent = `${data.series.length} å¸§ | ${duration.toFixed(2)}s | èŒƒå›´: ${minValue.toFixed(0)}-${maxValue.toFixed(0)}`;

                    // ä¸»ä¿¡å·æ•°æ®æ²¡æœ‰æ³¢å³°æ£€æµ‹ï¼Œæ˜¾ç¤º0
                    this.updatePeakIndicator(null);

                    console.log(`WaveformCapture: Displaying captured main signal data summary:`);
                    console.log(`  - Frames: ${data.series.length}`);
                    console.log(`  - Duration: ${duration.toFixed(2)}s`);
                    console.log(`  - Value range: ${minValue.toFixed(1)} - ${maxValue.toFixed(1)} (span: ${valueRange.toFixed(1)})`);
                    console.log(`  - Average: ${avgValue.toFixed(1)}`);
                    console.log(`  - Frame range: ${data.frame_range[0]}-${data.frame_range[1]}`);
                }

                // æ£€æŸ¥æ•°æ®å˜åŒ–æ˜¯å¦è¶³å¤Ÿ
                const values = dataSource === 'roi' ?
                    data.series.map(pt => pt.gray_value) :
                    data.series.map(pt => pt.value);

                const minValue = Math.min(...values);
                const maxValue = Math.max(...values);
                const valueRange = maxValue - minValue;

                if (valueRange < 5) {
                    console.warn(`WaveformCapture: WARNING - Small value range (${valueRange.toFixed(1)}) may appear as a flat line!`);
                } else if (valueRange < 20) {
                    console.warn(`WaveformCapture: Small value range (${valueRange.toFixed(1)}) - may appear subtle`);
                } else {
                    console.log(`WaveformCapture: Good value range (${valueRange.toFixed(1)}) - should be clearly visible`);
                }
            }

            showSubWaveform(series) {
                if (!series || series.length === 0) {
                    console.warn('WaveformCapture: No series data to show');
                    return;
                }

                console.log(`WaveformCapture: Showing sub-waveform with ${series.length} points`);

                // æ˜¾ç¤ºå®¹å™¨
                this.elements.container.style.display = 'flex';

                // è®¾ç½®æ•°æ®
                this.subWaveformChart.setData(series);

                // å»¶è¿Ÿæ˜¾ç¤ºåŠ¨ç”»ï¼Œç¡®ä¿æ•°æ®å·²ç»è®¾ç½®ä¸”å®¹å™¨å·²æ˜¾ç¤º
                setTimeout(() => {
                    this.elements.container.classList.add('show');
                    console.log('WaveformCapture: Sub-waveform container shown with animation');
                }, 50);
            }

            clearCapture() {
                this.capturedData = null;

                // ç§»é™¤åŠ¨ç”»ç±»
                this.elements.container.classList.remove('show');
                this.elements.infoPanel.classList.remove('show');

                // å»¶è¿Ÿéšè—ä»¥å®ŒæˆåŠ¨ç”»
                setTimeout(() => {
                    this.elements.container.style.display = 'none';
                    this.elements.infoPanel.style.display = 'none';
                }, 300);

                this.updateStatus('disconnected', 'ç­‰å¾…æˆªå–');
            }

            addSuccessFeedback() {
                // æŒ‰é’®æˆåŠŸåŠ¨ç”»
                this.elements.captureBtn.classList.add('success');
                setTimeout(() => {
                    this.elements.captureBtn.classList.remove('success');
                }, 1000);

                // éœ‡åŠ¨åé¦ˆï¼ˆå¦‚æœæ”¯æŒï¼‰
                if ('vibrate' in navigator) {
                    navigator.vibrate(50); // çŸ­éœ‡åŠ¨50ms
                }
            }

            updatePeakIndicator(peakResults) {
                const indicatorElement = document.getElementById('peak-indicator');
                const indicatorText = document.getElementById('peak-indicator-text');

                if (!indicatorElement || !indicatorText) {
                    return;
                }

                if (!peakResults || peakResults.error || peakResults.total_peaks === 0) {
                    // æ²¡æœ‰æ³¢å³°æˆ–é”™è¯¯æ—¶æ˜¾ç¤º0
                    indicatorText.textContent = '0';
                    indicatorText.style.backgroundColor = '#d32f2f'; // çº¢è‰²
                    indicatorText.style.color = 'white';
                } else {
                    // æ£€æŸ¥è·ç¦»æˆªå–ç‚¹æœ€è¿‘çš„æ³¢å³°é¢œè‰²
                    // æˆªå–ç‚¹é€šå¸¸æ˜¯æ•°æ®çš„ä¸­é—´ä½ç½®
                    const capturePoint = Math.floor(this.captureSettings.windowSize / 2);

                    let closestGreenDistance = Infinity;
                    let closestRedDistance = Infinity;

                    // æŸ¥æ‰¾æœ€è¿‘çš„ç»¿è‰²å’Œçº¢è‰²æ³¢å³°
                    if (peakResults.green_peaks && peakResults.green_peaks.length > 0) {
                        for (const [start, end] of peakResults.green_peaks) {
                            const peakCenter = Math.floor((start + end) / 2);
                            const distance = Math.abs(peakCenter - capturePoint);
                            if (distance < closestGreenDistance) {
                                closestGreenDistance = distance;
                            }
                        }
                    }

                    if (peakResults.red_peaks && peakResults.red_peaks.length > 0) {
                        for (const [start, end] of peakResults.red_peaks) {
                            const peakCenter = Math.floor((start + end) / 2);
                            const distance = Math.abs(peakCenter - capturePoint);
                            if (distance < closestRedDistance) {
                                closestRedDistance = distance;
                            }
                        }
                    }

                    // åˆ¤æ–­æœ€è¿‘çš„æ³¢å³°é¢œè‰²
                    if (closestGreenDistance < closestRedDistance) {
                        // æœ€è¿‘çš„æ³¢å³°æ˜¯ç»¿è‰²ï¼Œæ˜¾ç¤º1
                        indicatorText.textContent = '1';
                        indicatorText.style.backgroundColor = '#4caf50'; // ç»¿è‰²
                        indicatorText.style.color = 'white';
                    } else {
                        // æœ€è¿‘çš„æ³¢å³°æ˜¯çº¢è‰²æˆ–æ²¡æœ‰æ³¢å³°ï¼Œæ˜¾ç¤º0
                        indicatorText.textContent = '0';
                        indicatorText.style.backgroundColor = '#d32f2f'; // çº¢è‰²
                        indicatorText.style.color = 'white';
                    }
                }

                // æ˜¾ç¤ºæŒ‡ç¤ºå™¨
                indicatorElement.style.display = 'block';
            }

                    }

        /**
         * å­æ³¢å½¢å›¾è¡¨ç±»ï¼ˆç»§æ‰¿è‡ªWaveformChartï¼Œä½†ç‹¬ç«‹æ¸²æŸ“ï¼‰
         */
        class SubWaveformChart {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.container = document.querySelector('.subwaveform-chart-container');
                this.tooltip = document.getElementById('subwaveform-tooltip');

                this.data = [];
                this.zoom = 1.0;
                this.showGrid = true;
                this.showBaseline = true;
                this.showPoints = true;
                this.baseline = 100;
                this.isInitialized = false;
                this.mouseEventsBound = false;

                // å»¶è¿Ÿåˆå§‹åŒ–ï¼Œç­‰å¾…å®¹å™¨æ˜¾ç¤º
                this.initWhenReady();
                window.addEventListener('resize', () => this.resize());
            }

            initWhenReady() {
                // æ£€æŸ¥å®¹å™¨æ˜¯å¦å·²ç»æ˜¾ç¤º
                const checkContainer = () => {
                    if (this.container && this.container.offsetParent !== null) {
                        // å®¹å™¨å·²æ˜¾ç¤ºï¼Œè¿›è¡Œåˆå§‹åŒ–
                        this.resize();
                        this.isInitialized = true;

                        // ç»‘å®šé¼ æ ‡äº‹ä»¶ï¼ˆåªåœ¨å®¹å™¨æ˜¾ç¤ºåç»‘å®šä¸€æ¬¡ï¼‰
                        if (!this.mouseEventsBound) {
                            this.bindMouseEvents();
                            this.mouseEventsBound = true;
                            console.log('SubWaveformChart mouse events bound successfully');
                        }

                        console.log('SubWaveformChart initialized successfully');
                    } else {
                        // å®¹å™¨æœªæ˜¾ç¤ºï¼Œç»§ç»­ç­‰å¾…
                        setTimeout(checkContainer, 100);
                    }
                };
                checkContainer();
            }

            bindMouseEvents() {
                // ç»‘å®šé¼ æ ‡äº¤äº’äº‹ä»¶
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseleave', () => {
                    this.updateStatusBar('Ready');
                });
                console.log('SubWaveformChart: mouse events bound');
            }

            resize() {
                if (!this.container) {
                    console.warn('SubWaveformChart: container not found');
                    return;
                }

                const rect = this.container.getBoundingClientRect();

                // æ£€æŸ¥å®¹å™¨æ˜¯å¦æœ‰æœ‰æ•ˆå°ºå¯¸
                if (rect.width <= 0 || rect.height <= 0) {
                    console.warn('SubWaveformChart: container has invalid dimensions', rect);
                    return;
                }

                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.canvas.style.width = `${rect.width}px`;
                this.canvas.style.height = `${rect.height}px`;
                this.width = rect.width;
                this.height = rect.height;

                console.log('SubWaveformChart resized to', rect.width, 'x', rect.height);
                this.draw();
            }

            setData(series) {
                // æ•°æ®éªŒè¯
                if (!series || !Array.isArray(series)) {
                    console.error('SubWaveformChart: Invalid data provided', series);
                    return;
                }

                if (series.length === 0) {
                    console.warn('SubWaveformChart: Empty data array provided');
                    this.data = [];
                    return;
                }

                // éªŒè¯æ•°æ®æ ¼å¼
                const isValidData = series.every(pt =>
                    pt && typeof pt === 'object' &&
                    typeof pt.t === 'number' &&
                    typeof pt.value === 'number'
                );

                if (!isValidData) {
                    console.error('SubWaveformChart: Invalid data format', series);
                    return;
                }

                this.data = series;

                // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
                const values = series.map(pt => pt.value);
                const minValue = Math.min(...values);
                const maxValue = Math.max(...values);
                const avgValue = values.reduce((a, b) => a + b, 0) / values.length;
                this.baseline = avgValue;

                console.log(`SubWaveformChart: Set data with detailed statistics:`);
                console.log(`  - Points: ${series.length}`);
                console.log(`  - Time range: ${series[0].t.toFixed(2)}s - ${series[series.length-1].t.toFixed(2)}s`);
                console.log(`  - Value range: ${minValue.toFixed(2)} - ${maxValue.toFixed(2)} (span: ${(maxValue-minValue).toFixed(2)})`);
                console.log(`  - Baseline: ${this.baseline.toFixed(2)}`);
                console.log(`  - First 5 values:`, values.slice(0, 5).map(v => v.toFixed(1)));
                console.log(`  - Sample values at positions:`,
                    [0, Math.floor(series.length/4), Math.floor(series.length/2), Math.floor(3*series.length/4), series.length-1]
                    .map(i => `${i}:${values[i].toFixed(1)}`).join(', '));

                // å¦‚æœå·²åˆå§‹åŒ–ï¼Œç«‹å³é‡ç»˜
                if (this.isInitialized) {
                    this.draw();
                }
            }

            draw() {
                if (!this.ctx) {
                    console.error('SubWaveformChart: Canvas context not available');
                    return;
                }

                if (!this.isInitialized) {
                    console.warn('SubWaveformChart: Not yet initialized, skipping draw');
                    return;
                }

                if (this.data.length === 0) {
                    console.warn('SubWaveformChart: No data to draw');
                    return;
                }

                if (!this.width || !this.height || this.width <= 0 || this.height <= 0) {
                    console.warn('SubWaveformChart: Invalid canvas dimensions', this.width, this.height);
                    return;
                }

                const { width, height } = this;

                try {
                    // 1. æ¸…ç©ºèƒŒæ™¯
                    this.ctx.fillStyle = '#1a1a1a';
                    this.ctx.fillRect(0, 0, width, height);

                    console.log(`SubWaveformChart: Starting to draw ${this.data.length} points on ${width}x${height} canvas`);
                } catch (error) {
                    console.error('SubWaveformChart: Error during drawing', error);
                    return;
                }

                // è®¡ç®—æ•°æ®èŒƒå›´ç”¨äºè°ƒè¯•å’Œè‡ªåŠ¨ç¼©æ”¾
                const dataValues = this.data.map(pt => pt.value);
                const dataMin = Math.min(...dataValues);
                const dataMax = Math.max(...dataValues);
                const dataRange = dataMax - dataMin;

                // æ”¹è¿›çš„Yè½´æ˜ å°„ - ä½¿ç”¨æ•°æ®è‡ªåŠ¨ç¼©æ”¾
                let mapY;
                let scaleY;
                let midY;

                if (dataRange > 0 && dataRange < 50) {
                    // å¦‚æœæ•°æ®èŒƒå›´å¾ˆå°ï¼Œä½¿ç”¨è‡ªåŠ¨ç¼©æ”¾ä»¥çªå‡ºå˜åŒ–
                    const padding = dataRange * 0.2; // 20%è¾¹è·
                    const scaledMin = Math.max(0, dataMin - padding);
                    const scaledMax = Math.min(255, dataMax + padding);
                    const scaledRange = scaledMax - scaledMin;

                    scaleY = (height * 0.8) / scaledRange; // ä½¿ç”¨80%çš„é«˜åº¦
                    midY = height * 0.9; // åŸºå‡†ç‚¹åœ¨90%ä½ç½®
                    mapY = (val) => midY - (val - scaledMin) * scaleY;

                    console.log(`SubWaveformChart: Using auto-scale for small data range:`);
                    console.log(`  - Data range: ${dataRange.toFixed(2)} (small)`);
                    console.log(`  - Scaled range: ${scaledRange.toFixed(2)} (${scaledMin.toFixed(1)} - ${scaledMax.toFixed(1)})`);
                    console.log(`  - ScaleY: ${scaleY.toFixed(3)}`);
                } else {
                    // ä½¿ç”¨æ ‡å‡†æ˜ å°„
                    midY = height / 2;
                    scaleY = (height / 255) * this.zoom;
                    mapY = (val) => midY - (val - 128) * scaleY;

                    console.log(`SubWaveformChart: Using standard mapping:`);
                    console.log(`  - Data range: ${dataRange.toFixed(2)} (normal)`);
                }

                console.log(`SubWaveformChart: Y-axis mapping debug:`);
                console.log(`  - Canvas size: ${width}x${height}`);
                console.log(`  - MidY: ${midY.toFixed(1)}`);
                console.log(`  - ScaleY: ${scaleY.toFixed(3)} (zoom: ${this.zoom})`);
                console.log(`  - Data range: ${dataMin.toFixed(1)} - ${dataMax.toFixed(1)} (span: ${dataRange.toFixed(1)})`);
                console.log(`  - Y-mapping examples:`);
                console.log(`    * Value 0 -> Y: ${mapY(0).toFixed(1)}`);
                console.log(`    * Value 128 -> Y: ${mapY(128).toFixed(1)}`);
                console.log(`    * Value 255 -> Y: ${mapY(255).toFixed(1)}`);
                console.log(`    * Data min ${dataMin.toFixed(1)} -> Y: ${mapY(dataMin).toFixed(1)}`);
                console.log(`    * Data max ${dataMax.toFixed(1)} -> Y: ${mapY(dataMax).toFixed(1)}`);
                console.log(`    * Baseline ${this.baseline.toFixed(1)} -> Y: ${mapY(this.baseline).toFixed(1)}`);

                // æ£€æŸ¥æ˜ å°„æ˜¯å¦åˆç†
                if (mapY(dataMin) < 0 || mapY(dataMin) > height || mapY(dataMax) < 0 || mapY(dataMax) > height) {
                    console.warn(`SubWaveformChart: Y-mapping issue - data may be outside canvas bounds!`);
                }

                // 2. ç»˜åˆ¶ç½‘æ ¼
                if (this.showGrid) {
                    this.ctx.strokeStyle = '#333';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    // æ°´å¹³ç½‘æ ¼
                    for (let v = 0; v <= 255; v += 50) {
                        const y = mapY(v);
                        this.ctx.moveTo(0, y);
                        this.ctx.lineTo(width, y);
                    }
                    // å‚ç›´ç½‘æ ¼
                    const step = width / 10;
                    for (let x = 0; x < width; x += step) {
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, height);
                    }
                    this.ctx.stroke();
                }

                // Xè½´ æ­¥è¿›
                const stepX = width / (this.data.length - 1);

                // 3. ç»˜åˆ¶åŸºçº¿
                if (this.showBaseline) {
                    const yBase = mapY(this.baseline);
                    this.ctx.strokeStyle = '#dcdcaa';
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, yBase);
                    this.ctx.lineTo(width, yBase);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);

                    console.log(`SubWaveformChart: Baseline drawn at Y=${yBase.toFixed(1)} for value=${this.baseline.toFixed(2)}`);
                }

                // 4. ç»˜åˆ¶æ³¢å½¢
                this.ctx.strokeStyle = '#4ec9b0';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();

                let pointCount = 0;
                let uniqueYValues = new Set();

                this.data.forEach((pt, i) => {
                    const x = i * stepX;
                    const y = mapY(pt.value);

                    // æ”¶é›†è°ƒè¯•ä¿¡æ¯
                    uniqueYValues.add(y.toFixed(1));
                    pointCount++;

                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                        console.log(`SubWaveformChart: Drawing from first point at (${x.toFixed(1)}, ${y.toFixed(1)}) value=${pt.value.toFixed(1)}`);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.stroke();

                console.log(`SubWaveformChart: Waveform drawing completed:`);
                console.log(`  - Points drawn: ${pointCount}`);
                console.log(`  - Unique Y coordinates: ${uniqueYValues.size}`);
                console.log(`  - X step: ${stepX.toFixed(3)}`);
                console.log(`  - Sample drawing coordinates:`);

                // æ‰“å°å‡ ä¸ªå…³é”®ç‚¹çš„åæ ‡
                const sampleIndices = [0, Math.floor(this.data.length/4), Math.floor(this.data.length/2), Math.floor(3*this.data.length/4), this.data.length-1];
                sampleIndices.forEach(i => {
                    const pt = this.data[i];
                    const x = i * stepX;
                    const y = mapY(pt.value);
                    console.log(`    Point ${i}: value=${pt.value.toFixed(1)} -> (${x.toFixed(1)}, ${y.toFixed(1)})`);
                });

                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ç‚¹éƒ½æœ‰ç›¸åŒçš„Yåæ ‡ï¼ˆç›´çº¿ï¼‰
                if (uniqueYValues.size === 1) {
                    console.warn(`SubWaveformChart: WARNING - All points have the same Y coordinate! This explains why it looks like a straight line.`);
                } else if (uniqueYValues.size < 5) {
                    console.warn(`SubWaveformChart: WARNING - Very few unique Y coordinates (${uniqueYValues.size}). This may look like a straight line.`);
                }

                // 5. ç»˜åˆ¶æ•°æ®ç‚¹
                if (this.showPoints) {
                    this.ctx.fillStyle = '#fff';
                    this.data.forEach((pt, i) => {
                        const x = i * stepX;
                        const y = mapY(pt.value);
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    });
                    console.log(`SubWaveformChart: Drawn ${this.data.length} data points`);
                }
            }

            handleMouseMove(e) {
                // éªŒè¯å¿…è¦çš„å±æ€§
                if (!this.canvas || !this.data || this.data.length === 0) {
                    return;
                }

                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;

                // é˜²æ­¢é™¤é›¶é”™è¯¯
                if (this.data.length <= 1 || this.width <= 0) {
                    this.updateStatusBar('');
                    return;
                }

                const stepX = this.width / (this.data.length - 1);
                const index = Math.floor(mouseX / stepX);

                if (index >= 0 && index < this.data.length) {
                    const pt = this.data[index];
                    const baselineDiff = pt.value - this.baseline;
                    const relativePos = (index / (this.data.length - 1)) * 100;

                    // åœ¨åº•éƒ¨çŠ¶æ€æ æ˜¾ç¤ºæ•°å€¼ä¿¡æ¯
                    const valueColor = pt.value > this.baseline ? '#4ec9b0' : '#f44747';
                    const diffColor = baselineDiff > 0 ? '#4ec9b0' : '#f44747';

                    const statusText = `æˆªå–æ³¢å½¢ | ç´¢å¼•: ${index} | æ—¶é—´: ${pt.t.toFixed(2)}s | æ•°å€¼: ${pt.value.toFixed(1)} | åŸºçº¿: ${this.baseline.toFixed(1)} | å·®å¼‚: ${baselineDiff > 0 ? '+' : ''}${baselineDiff.toFixed(1)} | ä½ç½®: ${relativePos.toFixed(1)}%`;

                    this.updateStatusBar(statusText);
                } else {
                    this.updateStatusBar('');
                }
            }

            updateStatusBar(text) {
                const chartStatusElement = document.getElementById('chart-status');
                if (chartStatusElement) {
                    chartStatusElement.textContent = text || 'Ready';
                }
        }

        }

        class RoiRenderer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');

                // åˆ›å»ºç¦»å±Canvasç”¨äºåŒç¼“å†²
                this.offscreenCanvas = document.createElement('canvas');
                this.offscreenCanvas.width = 200;
                this.offscreenCanvas.height = 150;
                this.offscreenCtx = this.offscreenCanvas.getContext('2d');

                // å›¾åƒé¢„åŠ è½½
                this.preloadedImage = null;
                this.isLoading = false;
            }

            render(roiData) {
                if (!roiData) {
                    this.drawPlaceholder("ROIæ•°æ®æœªåˆå§‹åŒ–");
                    return;
                }

               if (roiData.format === 'base64') {
                    // é¢„åŠ è½½å›¾åƒï¼Œé¿å…é—ªçƒ
                    this.preloadAndRender(roiData.pixels);
                } else if (roiData.pixels === 'roi_not_configured') {
                    this.drawPlaceholder("è¯·å…ˆé…ç½®ROIåŒºåŸŸ");
                } else if (roiData.pixels === 'roi_capture_failed') {
                    this.drawPlaceholder("ROIæˆªå›¾å¤±è´¥");
                } else if (roiData.pixels === 'roi_capture_error') {
                    this.drawPlaceholder("ROIæˆªå›¾é”™è¯¯");
                } else {
                    this.drawPlaceholder("ROIæ•°æ®æ ¼å¼: " + roiData.pixels);
                }
            }

            preloadAndRender(imageSrc) {
                // é¿å…é‡å¤åŠ è½½ç›¸åŒå›¾åƒ
                if (this.preloadedImage && this.preloadedImage.src === imageSrc) {
                    return;
                }

                if (this.isLoading) {
                    return; // å¦‚æœæ­£åœ¨åŠ è½½ï¼Œè·³è¿‡
                }

                this.isLoading = true;
                const img = new Image();

                img.onload = () => {
                    // æ¸…ç©ºç¦»å±Canvas
                    this.offscreenCtx.clearRect(0, 0, 200, 150);
                    // ç»˜åˆ¶å›¾åƒåˆ°ç¦»å±Canvas
                    this.offscreenCtx.drawImage(img, 0, 0, 200, 150);
                    // ä¸€æ¬¡æ€§å¤åˆ¶åˆ°ä¸»Canvas
                    this.copyToMainCanvas();
                    // ç¼“å­˜å›¾åƒ
                    this.preloadedImage = img;
                    this.isLoading = false;
                };

                img.onerror = () => {
                    this.isLoading = false;
                    this.drawPlaceholder("å›¾åƒåŠ è½½å¤±è´¥");
                };

                img.src = imageSrc;
            }

            copyToMainCanvas() {
                // æ¸…ç©ºä¸»Canvas
                this.ctx.clearRect(0, 0, 200, 150);
                // ä¸€æ¬¡æ€§å¤åˆ¶ç¦»å±Canvaså†…å®¹åˆ°ä¸»Canvas
                this.ctx.drawImage(this.offscreenCanvas, 0, 0);
            }

            drawPlaceholder(message) {
                // ç›´æ¥åœ¨ç¦»å±Canvasä¸Šç»˜åˆ¶
                this.drawPlaceholderToCanvas(this.offscreenCtx, message);
                // å¤åˆ¶åˆ°ä¸»Canvas
                this.copyToMainCanvas();
            }

            drawPlaceholderToCanvas(ctx, message) {
                // ç»˜åˆ¶èƒŒæ™¯
                ctx.fillStyle = '#2d2d30';
                ctx.fillRect(0, 0, 200, 150);

                // ç»˜åˆ¶è¾¹æ¡†
                ctx.strokeStyle = '#3e3e42';
                ctx.strokeRect(0, 0, 200, 150);

                // ç»˜åˆ¶æ–‡å­—
                ctx.fillStyle = '#cccccc';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // å¤šè¡Œæ–‡å­—å¤„ç†
                const lines = message.split(' ');
                const lineHeight = 20;
                const startY = 75 - (lines.length - 1) * lineHeight / 2;

                lines.forEach((line, index) => {
                    ctx.fillText(line, 100, startY + index * lineHeight);
                });
            }
        }

        /**
         * 5. æ ¸å¿ƒæ§åˆ¶å™¨ (Main Controller)
         */
        const chartRenderer = new WaveformChart('waveform-chart');
        const roiRenderer = new RoiRenderer('roi-canvas');
        const waveformCapture = new WaveformCapture();

        
        // æ›´æ–° UI å…ƒç´ 
        function updateUI() {
            // è¿æ¥çŠ¶æ€
            const connInd = document.getElementById('connection-indicator');
            const connTxt = document.getElementById('connection-text');
            if (appState.connected) {
                connInd.className = 'indicator connected';
                connTxt.innerText = 'Connected';
            } else {
                connInd.className = 'indicator disconnected';
                connTxt.innerText = 'Disconnected';
            }

            // æ•°å€¼é¢æ¿
            document.getElementById('frame-count').innerText = appState.frameCount;
            document.getElementById('current-value').innerText = appState.currentValue.toFixed(2);
            document.getElementById('baseline-value').innerText = appState.baseline.toFixed(2);
            document.getElementById('buffer-size').innerText = appState.chartData.length;
            
            // æ³¢å³°ä¿¡å·
            const peakEl = document.getElementById('peak-signal');
            if (appState.peakSignal === 1) {
                peakEl.className = 'status-value signal-green';
                peakEl.innerText = 'DETECTED';
            } else if (appState.peakSignal === 0) {
                peakEl.className = 'status-value signal-red';
                peakEl.innerText = 'WEAK';
            } else {
                peakEl.className = 'status-value signal-none';
                peakEl.innerText = 'NULL';
            }

            // ROIé…ç½®çŠ¶æ€
            const roiStatusIndicator = document.getElementById('roi-status-indicator');
            const roiStatusText = document.getElementById('roi-status-text');
            if (appState.roiConfigured) {
                roiStatusIndicator.className = 'indicator connected';
                roiStatusText.innerText = 'å·²é…ç½®';
            } else {
                roiStatusIndicator.className = 'indicator disconnected';
                roiStatusText.innerText = 'æœªé…ç½®';
            }

            // ROIæ•°æ®
            if (appState.roiData) {
                document.getElementById('roi-gray-value').innerText = appState.roiData.gray_value.toFixed(2);
            }

            // æ£€æµ‹çŠ¶æ€
            document.getElementById('detection-state').innerText = appState.detectionState;

            // æŒ‰é’®çŠ¶æ€
            const isRunning = appState.detectionState === 'RUNNING';
            const isPaused = appState.detectionState === 'PAUSED';
            const isIdle = appState.detectionState === 'IDLE' || appState.detectionState === 'STOPPED';
            const roiConfigured = appState.roiConfigured;

            // å¼€å§‹æ£€æµ‹æŒ‰é’®ï¼šéœ€è¦ROIå·²é…ç½®ä¸”ä¸åœ¨è¿è¡ŒçŠ¶æ€
            document.getElementById('start-btn').disabled = isRunning || !roiConfigured;
            document.getElementById('stop-btn').disabled = isIdle;
            document.getElementById('pause-btn').disabled = !isRunning;
            document.getElementById('resume-btn').disabled = !isPaused;

            // Update Time
            const now = new Date();
            document.getElementById('last-update').innerText = `Update: ${now.toLocaleTimeString()}`;
        }

        // åŠ¨æ€è½®è¯¢é—´éš”ç®¡ç†
        function updatePollingInterval() {
            const isRunning = appState.detectionState === 'RUNNING';
            const isPaused = appState.detectionState === 'PAUSED';

            // æ¸…é™¤å½“å‰è½®è¯¢
            if (appState.pollingIntervals.realtime) {
                clearInterval(appState.pollingIntervals.realtime);
                appState.pollingIntervals.realtime = null;
            }

            // æ ¹æ®çŠ¶æ€è®¾ç½®æ–°çš„è½®è¯¢é—´éš”
            if (isRunning || isPaused) {
                // è¿è¡Œæˆ–æš‚åœçŠ¶æ€ï¼šæ ¹æ®ROIå¸§ç‡è°ƒæ•´è½®è¯¢é¢‘ç‡
                let pollingInterval;
                if (appState.roiConfigured) {
                    // ROIå·²é…ç½®ï¼šè½®è¯¢é—´éš”ç²¾ç¡®åŒ¹é…ROIå¸§ç‡
                    pollingInterval = Math.floor(1000 / appState.roiFrameRate);
                    const updateFreq = appState.roiFrameRate;
                    document.getElementById('chart-status').innerText =
                        `System Active | ROI: ${appState.roiFrameRate}FPS | Data: ${updateFreq} points/sec`;
                } else {
                    // ROIæœªé…ç½®ï¼šä½¿ç”¨é»˜è®¤çš„é«˜é¢‘ç‡è½®è¯¢æ¨¡æ‹Ÿæ•°æ®
                    pollingInterval = 50; // 20 FPS
                    document.getElementById('chart-status').innerText = "System Active | Simulated: 20FPS";
                }
                appState.pollingIntervals.realtime = setInterval(updateRealtimeData, pollingInterval);
            } else {
                // åœæ­¢çŠ¶æ€ï¼šé™ä½é¢‘ç‡åˆ°2ç§’é—´éš”
                appState.pollingIntervals.realtime = setInterval(updateRealtimeData, 2000);
                document.getElementById('chart-status').innerText = "System Stopped | Polling: 0.5FPS";
            }
        }

        // æ ¸å¿ƒè½®è¯¢å¾ªç¯
        async function updateRealtimeData() {
            if (!appState.connected) return;

            // æ ¹æ®æ£€æµ‹çŠ¶æ€å†³å®šæ˜¯å¦è¿›è¡Œè½®è¯¢
            const isRunning = appState.detectionState === 'RUNNING';
            const isPaused = appState.detectionState === 'PAUSED';

            // å¦‚æœç³»ç»Ÿåœæ­¢ï¼Œé™ä½è½®è¯¢é¢‘ç‡æˆ–ç›´æ¥è¿”å›
            if (!isRunning && !isPaused) {
                console.log('System stopped, skipping realtime data request');
                return;
            }

            const data = await ApiService.fetchRealtimeData();
            if (data && data.type === 'realtime_data') {
                // æ›´æ–°å…¨å±€æ•°æ®
                appState.frameCount = data.frame_count;
                appState.peakSignal = data.peak_signal;
                appState.baseline = data.baseline;

                // æ§åˆ¶ROIæ›´æ–°é¢‘ç‡ - é™ä½åˆ°2 FPSï¼Œå‡å°‘é—ªçƒ
                const now = Date.now();
                if (now - appState.lastRoiUpdate > appState.roiUpdateInterval) {
                    appState.roiData = data.roi_data;
                    appState.lastRoiUpdate = now;
                }

                if (data.series && data.series.length > 0) {
                    const latest = data.series[data.series.length - 1];
                    appState.currentValue = latest.value;
                    
                    // ç»´æŠ¤å›ºå®šé•¿åº¦çš„å›¾è¡¨æ•°æ®é˜Ÿåˆ—
                    data.series.forEach(pt => {
                        appState.chartData.push(pt);
                    });
                    while (appState.chartData.length > appState.maxDataPoints) {
                        appState.chartData.shift();
                    }
                }

                // æ›´æ–°æ³¢å³°æ£€æµ‹çŠ¶æ€æ˜¾ç¤º
                if (data.enhanced_peak) {
                    updatePeakDetectionStatus(data.enhanced_peak);
                } else {
                    updatePeakDetectionStatus(null);
                }

                // æ¸²æŸ“æ›´æ–°
                chartRenderer.draw();
                roiRenderer.render(data.roi_data);
                updateUI();
            }
        }

        // çŠ¶æ€æœºæ§åˆ¶
        async function handleControl(action) {
            // æ£€æŸ¥ROIé…ç½®çŠ¶æ€ï¼ˆä»…å¯¹å¼€å§‹æ£€æµ‹ï¼‰
            if (action === 'start_detection' && !appState.roiConfigured) {
                alert('è¯·å…ˆé…ç½®ROIåŒºåŸŸåå†å¼€å§‹æ£€æµ‹ï¼');
                return;
            }

            // å…ˆä¹è§‚æ›´æ–°UI
            const oldState = appState.detectionState;

            let newState = oldState;
            if (action === 'start_detection') newState = 'RUNNING';
            if (action === 'stop_detection') newState = 'STOPPED';
            if (action === 'pause_detection') newState = 'PAUSED';
            if (action === 'resume_detection') newState = 'RUNNING';

            appState.detectionState = newState;
            updateUI();

            // å‘é€å‘½ä»¤
            const res = await ApiService.sendControl(action);
            if (res.status !== 'success') {
                alert('Command failed!');
                appState.detectionState = oldState; // å›æ»š
                updateUI();
                updatePollingInterval(); // æ¢å¤åŸæ¥çš„è½®è¯¢é—´éš”
            } else {
                // å‘½ä»¤æˆåŠŸï¼Œæ›´æ–°è½®è¯¢é—´éš”
                updatePollingInterval();
            }
        }

        // è¿æ¥é€»è¾‘
        function initConnection() {
            const ind = document.getElementById('connection-indicator');
            const txt = document.getElementById('connection-text');
            ind.className = 'indicator connecting';
            txt.innerText = 'Connecting...';

            setTimeout(async () => {
                appState.connected = true;
                updateUI();

                // åŠ è½½ROIé…ç½®
                await loadRoiConfig();

                // åŠ è½½æ³¢å³°æ£€æµ‹é…ç½®
                await loadPeakDetectionConfig();

                // å¯åŠ¨åŠ¨æ€è½®è¯¢
                updatePollingInterval();
            }, 1000);
        }

        /**
         * 5. ROIç›¸å…³å‡½æ•°
         */
        function updateRoiDisplay() {
            // è·å–è¾“å…¥å€¼
            const x1 = parseInt(document.getElementById('roi-x1').value) || 0;
            const y1 = parseInt(document.getElementById('roi-y1').value) || 0;
            const x2 = parseInt(document.getElementById('roi-x2').value) || 0;
            const y2 = parseInt(document.getElementById('roi-y2').value) || 0;

            // è®¡ç®—ä¸­å¿ƒç‚¹å’Œå°ºå¯¸
            const centerX = Math.floor((x1 + x2) / 2);
            const centerY = Math.floor((y1 + y2) / 2);
            const width = Math.abs(x2 - x1);
            const height = Math.abs(y2 - y1);

            // æ›´æ–°æ˜¾ç¤º
            document.getElementById('roi-center').textContent = `(${centerX}, ${centerY})`;
            document.getElementById('roi-width').textContent = `${width} px`;
            document.getElementById('roi-height').textContent = `${height} px`;
        }

        // ä¿å­˜é…ç½®åˆ°localStorage
        function saveConfiguration() {
            // ä¿å­˜ROIé…ç½®
            const roiConfig = {
                x1: parseInt(document.getElementById('roi-x1').value) || 0,
                y1: parseInt(document.getElementById('roi-y1').value) || 0,
                x2: parseInt(document.getElementById('roi-x2').value) || 0,
                y2: parseInt(document.getElementById('roi-y2').value) || 0,
                frameRate: parseInt(document.getElementById('roi-frame-rate').value) || 2,
                lastUpdated: new Date().toISOString()
            };
            localStorage.setItem('newfem_roi_config', JSON.stringify(roiConfig));

            // ä¿å­˜æ³¢å³°æ£€æµ‹é…ç½®ï¼ˆä½¿ç”¨ç°æœ‰çš„å‡½æ•°ï¼‰
            const peakConfig = {
                threshold: parseFloat(document.getElementById('peak-threshold').value) || 105.0,
                margin_frames: parseInt(document.getElementById('peak-margin-frames').value) || 5,
                difference_threshold: parseFloat(document.getElementById('peak-difference-threshold').value) || 2.1,
                min_region_length: parseInt(document.getElementById('peak-min-region-length').value) || 3
            };
            savePeakDetectionConfigToLocalStorage(peakConfig);

            console.log('Configuration saved to localStorage');
        }

        // ä»localStorageåŠ è½½ROIé…ç½®
        function loadRoiConfigFromStorage() {
            const savedConfig = localStorage.getItem('newfem_roi_config');
            if (savedConfig) {
                try {
                    const config = JSON.parse(savedConfig);
                    return config;
                } catch (e) {
                    console.warn('Failed to parse saved ROI configuration:', e);
                    return null;
                }
            }
            return null;
        }

        // åº”ç”¨ä¿å­˜çš„é…ç½®åˆ°ç•Œé¢
        function applySavedConfigToUI() {
            // åŠ è½½å¹¶åº”ç”¨ROIé…ç½®
            const roiConfig = loadRoiConfigFromStorage();
            if (roiConfig) {
                document.getElementById('roi-x1').value = roiConfig.x1;
                document.getElementById('roi-y1').value = roiConfig.y1;
                document.getElementById('roi-x2').value = roiConfig.x2;
                document.getElementById('roi-y2').value = roiConfig.y2;
                document.getElementById('roi-frame-rate').value = roiConfig.frameRate;
                updateRoiDisplay();
                updateRoiFrameRateDisplay();
                console.log('ROI configuration loaded from localStorage:', roiConfig);
            }

            // åŠ è½½å¹¶åº”ç”¨æ³¢å³°æ£€æµ‹é…ç½®ï¼ˆä½¿ç”¨ç°æœ‰çš„å‡½æ•°ï¼‰
            const peakConfig = loadPeakDetectionConfigFromLocalStorage();
            if (peakConfig) {
                document.getElementById('peak-threshold').value = peakConfig.threshold;
                document.getElementById('peak-margin-frames').value = peakConfig.margin_frames;
                document.getElementById('peak-difference-threshold').value = peakConfig.difference_threshold;
                document.getElementById('peak-min-region-length').value = peakConfig.min_region_length;
                console.log('Peak detection configuration loaded from localStorage:', peakConfig);
            }

            // è¿”å›æ˜¯å¦æœ‰ä»»ä½•é…ç½®è¢«åŠ è½½
            return roiConfig || peakConfig;
        }

        async function applyRoiConfig() {
            try {
                const x1 = parseInt(document.getElementById('roi-x1').value) || 0;
                const y1 = parseInt(document.getElementById('roi-y1').value) || 0;
                const x2 = parseInt(document.getElementById('roi-x2').value) || 0;
                const y2 = parseInt(document.getElementById('roi-y2').value) || 0;
                const frameRate = parseInt(document.getElementById('roi-frame-rate').value) || 2;

                // åŸºæœ¬éªŒè¯
                if (x1 >= x2 || y1 >= y2) {
                    alert('ROIåæ ‡æ— æ•ˆï¼šx1å¿…é¡»å°äºx2ï¼Œy1å¿…é¡»å°äºy2');
                    return;
                }

                if (x2 - x1 < 10 || y2 - y1 < 10) {
                    alert('ROIå°ºå¯¸å¤ªå°ï¼šæœ€å°å°ºå¯¸ä¸º10x10åƒç´ ');
                    return;
                }

                if (frameRate < 1 || frameRate > 60) {
                    alert('å¸§ç‡æ— æ•ˆï¼šå¿…é¡»åœ¨1-60ä¹‹é—´');
                    return;
                }

                // åŒæ—¶åº”ç”¨ROIé…ç½®å’Œå¸§ç‡è®¾ç½®
                const [roiResponse, frameRateResponse] = await Promise.all([
                    ApiService.setRoiConfig(x1, y1, x2, y2),
                    ApiService.setRoiFrameRate(frameRate)
                ]);

                // æ£€æŸ¥ROIé…ç½®ç»“æœ
                if (roiResponse && roiResponse.success) {
                    // æ›´æ–°æœ¬åœ°çŠ¶æ€
                    appState.roiConfig = roiResponse.config;
                    appState.roiConfigured = true;
                    console.log('ROIé…ç½®åº”ç”¨æˆåŠŸ:', roiResponse.config);
                } else {
                    alert('ROIé…ç½®åº”ç”¨å¤±è´¥: ' + (roiResponse?.error || 'æœªçŸ¥é”™è¯¯'));
                    return;
                }

                // æ£€æŸ¥å¸§ç‡è®¾ç½®ç»“æœ
                if (frameRateResponse && frameRateResponse.success) {
                    console.log('ROIå¸§ç‡è®¾ç½®æˆåŠŸ:', frameRateResponse.frame_rate);
                    // æ›´æ–°åº”ç”¨çŠ¶æ€
                    appState.roiFrameRate = frameRate;
                    appState.roiUpdateInterval = Math.floor(1000 / frameRate);
                    updateRoiFrameRateDisplay();
                } else {
                    console.warn('ROIå¸§ç‡è®¾ç½®å¤±è´¥: ' + (frameRateResponse?.error || 'æœªçŸ¥é”™è¯¯'));
                }

                // ä¿å­˜é…ç½®åˆ°localStorage (ä»…åœ¨ROIé…ç½®æˆåŠŸæ—¶ä¿å­˜)
                if (roiResponse && roiResponse.success) {
                    saveConfiguration();
                }

                updateUI();  // æ›´æ–°UIçŠ¶æ€
            } catch (error) {
                console.error('Apply ROI config error:', error);
                alert('ROIé…ç½®åº”ç”¨å¤±è´¥: ' + error.message);
            }
        }

        
        async function loadRoiConfig() {
            try {
                const response = await ApiService.getRoiConfig();
                if (response && response.success && response.config) {
                    appState.roiConfig = response.config;
                    // å¦‚æœé…ç½®ä¸æ˜¯é»˜è®¤å€¼ï¼Œåˆ™è®¤ä¸ºå·²é…ç½®
                    const isDefaultConfig = (response.config.x1 === 0 && response.config.y1 === 0 &&
                                            response.config.x2 === 200 && response.config.y2 === 150);
                    appState.roiConfigured = !isDefaultConfig;

                    // æ›´æ–°UIè¾“å…¥æ¡†
                    document.getElementById('roi-x1').value = response.config.x1;
                    document.getElementById('roi-y1').value = response.config.y1;
                    document.getElementById('roi-x2').value = response.config.x2;
                    document.getElementById('roi-y2').value = response.config.y2;

                    // æ›´æ–°æ˜¾ç¤º
                    updateRoiDisplay();

                    console.log('ROIé…ç½®åŠ è½½æˆåŠŸ:', response.config, 'é…ç½®çŠ¶æ€:', appState.roiConfigured);
                }

                // åŠ è½½ROIå¸§ç‡è®¾ç½®
                await loadRoiFrameRate();
            } catch (error) {
                console.error('åŠ è½½ROIé…ç½®å¤±è´¥:', error);
            }
        }

        async function loadRoiFrameRate() {
            try {
                const response = await ApiService.getRoiFrameRate();
                if (response && response.success) {
                    document.getElementById('roi-frame-rate').value = response.frame_rate;
                    document.getElementById('roi-fps-display').textContent = `${response.frame_rate} FPS`;
                    // æ›´æ–°åº”ç”¨çŠ¶æ€
                    appState.roiFrameRate = response.frame_rate;
                    appState.roiUpdateInterval = Math.floor(1000 / response.frame_rate);
                    console.log('ROIå¸§ç‡åŠ è½½æˆåŠŸ:', response.frame_rate);
                }
            } catch (error) {
                console.error('åŠ è½½ROIå¸§ç‡å¤±è´¥:', error);
            }
        }

        /**
         * 7. æ³¢å³°æ£€æµ‹é…ç½®å‡½æ•°
         */
        function savePeakDetectionConfigToLocalStorage(config) {
            try {
                const data = {
                    ...config,
                    lastUpdated: new Date().toISOString()
                };
                localStorage.setItem('newfem_peak_detection_config', JSON.stringify(data));
                console.log('Peak detection config saved to localStorage:', data);
            } catch (error) {
                console.warn('Failed to save peak detection config to localStorage:', error);
            }
        }

        function loadPeakDetectionConfigFromLocalStorage() {
            try {
                const stored = localStorage.getItem('newfem_peak_detection_config');
                if (stored) {
                    const config = JSON.parse(stored);
                    console.log('Peak detection config loaded from localStorage:', config);
                    return config;
                }
                return null;
            } catch (error) {
                console.warn('Failed to load peak detection config from localStorage:', error);
                return null;
            }
        }

        async function loadPeakDetectionConfig() {
            try {
                // é¦–å…ˆå°è¯•ä»localStorageåŠ è½½é…ç½®
                let localConfig = loadPeakDetectionConfigFromLocalStorage();

                if (localConfig) {
                    // ä½¿ç”¨æœ¬åœ°é…ç½®æ›´æ–°UI
                    document.getElementById('peak-threshold').value = localConfig.threshold;
                    document.getElementById('peak-margin-frames').value = localConfig.margin_frames;
                    document.getElementById('peak-difference-threshold').value = localConfig.difference_threshold;
                    document.getElementById('peak-min-region-length').value = localConfig.min_region_length;

                    // æ›´æ–°åº”ç”¨çŠ¶æ€
                    appState.peakConfig = {
                        threshold: localConfig.threshold,
                        margin_frames: localConfig.margin_frames,
                        difference_threshold: localConfig.difference_threshold,
                        min_region_length: localConfig.min_region_length
                    };

                    // åŒæ—¶åº”ç”¨åˆ°åç«¯ä»¥ä¿æŒåŒæ­¥
                    const backendResponse = await ApiService.setPeakDetectionConfig({
                        threshold: localConfig.threshold,
                        margin_frames: localConfig.margin_frames,
                        difference_threshold: localConfig.difference_threshold,
                        min_region_length: localConfig.min_region_length
                    });

                    if (backendResponse && backendResponse.success) {
                        console.log('æ³¢å³°æ£€æµ‹é…ç½®ä»æœ¬åœ°åŠ è½½å¹¶åŒæ­¥åˆ°åç«¯æˆåŠŸ:', localConfig);
                    } else {
                        console.warn('æ³¢å³°æ£€æµ‹é…ç½®ä»æœ¬åœ°åŠ è½½ä½†åŒæ­¥åˆ°åç«¯å¤±è´¥:', backendResponse?.error);
                    }
                } else {
                    // æœ¬åœ°æ— é…ç½®ï¼Œä»APIåŠ è½½é»˜è®¤é…ç½®
                    const response = await ApiService.getPeakDetectionConfig();
                    if (response && response.success) {
                        // æ›´æ–°UIè¾“å…¥æ¡†
                        document.getElementById('peak-threshold').value = response.threshold;
                        document.getElementById('peak-margin-frames').value = response.margin_frames;
                        document.getElementById('peak-difference-threshold').value = response.difference_threshold;
                        document.getElementById('peak-min-region-length').value = response.min_region_length;

                        // æ›´æ–°åº”ç”¨çŠ¶æ€
                        appState.peakConfig = {
                            threshold: response.threshold,
                            margin_frames: response.margin_frames,
                            difference_threshold: response.difference_threshold,
                            min_region_length: response.min_region_length
                        };

                        // ä¿å­˜åˆ°localStorageä¾›ä¸‹æ¬¡ä½¿ç”¨
                        savePeakDetectionConfigToLocalStorage(appState.peakConfig);

                        console.log('æ³¢å³°æ£€æµ‹é…ç½®ä»APIåŠ è½½æˆåŠŸ:', response);
                    }
                }
            } catch (error) {
                console.error('åŠ è½½æ³¢å³°æ£€æµ‹é…ç½®å¤±è´¥:', error);
                // å‘ç”Ÿé”™è¯¯æ—¶ä½¿ç”¨é»˜è®¤é…ç½®
                const defaultConfig = appState.peakConfig;
                document.getElementById('peak-threshold').value = defaultConfig.threshold;
                document.getElementById('peak-margin-frames').value = defaultConfig.margin_frames;
                document.getElementById('peak-difference-threshold').value = defaultConfig.difference_threshold;
                document.getElementById('peak-min-region-length').value = defaultConfig.min_region_length;
            }
        }

        async function applyPeakDetectionConfig() {
            try {
                // åªè¯»å–4ä¸ªå‚æ•°
                const threshold = parseFloat(document.getElementById('peak-threshold').value) || 105.0;
                const marginFrames = parseInt(document.getElementById('peak-margin-frames').value) || 5;
                const differenceThreshold = parseFloat(document.getElementById('peak-difference-threshold').value) || 2.1;
                const minRegionLength = parseInt(document.getElementById('peak-min-region-length').value) || 3;

                // åŸºæœ¬å‚æ•°éªŒè¯
                if (threshold < 50.0 || threshold > 255.0) {
                    console.warn('ç»å¯¹é˜ˆå€¼è¶…å‡ºèŒƒå›´ï¼š', threshold);
                    return;
                }

                if (marginFrames < 1 || marginFrames > 20) {
                    console.warn('è¾¹ç•Œæ‰©å±•å¸§æ•°è¶…å‡ºèŒƒå›´ï¼š', marginFrames);
                    return;
                }

                if (differenceThreshold < 0.1 || differenceThreshold > 10.0) {
                    console.warn('é¢œè‰²åˆ†ç±»é˜ˆå€¼è¶…å‡ºèŒƒå›´ï¼š', differenceThreshold);
                    return;
                }

                if (minRegionLength < 1 || minRegionLength > 20) {
                    console.warn('æœ€å°åŒºåŸŸé•¿åº¦è¶…å‡ºèŒƒå›´ï¼š', minRegionLength);
                    return;
                }

                // åªä¿å­˜é…ç½®åˆ°localStorage
                const config = {
                    threshold: threshold,
                    margin_frames: marginFrames,
                    difference_threshold: differenceThreshold,
                    min_region_length: minRegionLength
                };

                savePeakDetectionConfigToLocalStorage(config);
                console.log('æ³¢å³°æ£€æµ‹é…ç½®å·²ä¿å­˜åˆ°æœ¬åœ°:', config);

            } catch (error) {
                console.error('ä¿å­˜æ³¢å³°æ£€æµ‹é…ç½®å¤±è´¥:', error);
            }
        }

        function updatePeakDetectionStatus(peakData) {
            if (!peakData) {
                document.getElementById('peak-status-indicator').className = 'indicator disconnected';
                document.getElementById('peak-status-text').textContent = 'æœªæ¿€æ´»';
                document.getElementById('current-peak-color').innerHTML = '<span class="status-value">-</span>';
                return;
            }

            // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
            if (peakData.signal === 1) {
                document.getElementById('peak-status-indicator').className = 'indicator running';
                document.getElementById('peak-status-text').textContent = 'æ£€æµ‹åˆ°æ³¢å³°';

                // æ›´æ–°é¢œè‰²æ˜¾ç¤º
                if (peakData.color === 'green') {
                    document.getElementById('current-peak-color').innerHTML =
                        '<span style="color: #4ec9b0; font-weight: bold;">ğŸŸ¢ ç»¿è‰²æ³¢å³° (ç¨³å®š)</span>';
                } else if (peakData.color === 'red') {
                    document.getElementById('current-peak-color').innerHTML =
                        '<span style="color: #f44747; font-weight: bold;">ğŸ”´ çº¢è‰²æ³¢å³° (å¯èƒ½ä¸ç¨³å®š)</span>';
                } else {
                    document.getElementById('current-peak-color').innerHTML =
                        '<span class="status-value">æ³¢å³° (é¢œè‰²æœªçŸ¥)</span>';
                }
            } else {
                document.getElementById('peak-status-indicator').className = 'indicator connecting';
                document.getElementById('peak-status-text').textContent = 'ç›‘æ§ä¸­';
                document.getElementById('current-peak-color').innerHTML = '<span class="status-value">-</span>';
            }
        }

        function updateRoiFrameRateDisplay() {
            const frameRate = parseInt(document.getElementById('roi-frame-rate').value) || 2;
            document.getElementById('roi-fps-display').textContent = `${frameRate} FPS`;
        }

        async function applyRoiFrameRate() {
            try {
                const frameRate = parseInt(document.getElementById('roi-frame-rate').value) || 2;

                // éªŒè¯å¸§ç‡èŒƒå›´
                if (frameRate < 1 || frameRate > 60) {
                    alert('å¸§ç‡æ— æ•ˆï¼šå¿…é¡»åœ¨1-60ä¹‹é—´');
                    return;
                }

                // å‘é€APIè¯·æ±‚
                const response = await ApiService.setRoiFrameRate(frameRate);
                if (response && response.success) {
                    console.log('ROIå¸§ç‡è®¾ç½®æˆåŠŸ:', response.frame_rate);
                    // æ›´æ–°åº”ç”¨çŠ¶æ€
                    appState.roiFrameRate = frameRate;
                    appState.roiUpdateInterval = Math.floor(1000 / frameRate);
                    // æ›´æ–°æ˜¾ç¤º
                    updateRoiFrameRateDisplay();
                    // å¦‚æœç³»ç»Ÿæ­£åœ¨è¿è¡Œï¼Œé‡æ–°è®¾ç½®è½®è¯¢é—´éš”ä»¥åº”ç”¨æ–°çš„å¸§ç‡
                    if (appState.detectionState === 'RUNNING' || appState.detectionState === 'PAUSED') {
                        updatePollingInterval();
                    }
                } else {
                    alert('ROIå¸§ç‡è®¾ç½®å¤±è´¥: ' + (response.error || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (error) {
                console.error('Apply ROI frame rate error:', error);
                alert('ROIå¸§ç‡è®¾ç½®å¤±è´¥: ' + error.message);
            }
        }

        /**
         * 6. äº‹ä»¶ç»‘å®š
         */
        document.addEventListener('DOMContentLoaded', () => {
            // æ˜¾ç¤ºæ§åˆ¶
            document.getElementById('show-grid').addEventListener('change', (e) => {
                appState.chartState.showGrid = e.target.checked;
                chartRenderer.draw();
            });
            document.getElementById('show-baseline').addEventListener('change', (e) => {
                appState.chartState.showBaseline = e.target.checked;
                chartRenderer.draw();
            });
            document.getElementById('show-points').addEventListener('change', (e) => {
                appState.chartState.showPoints = e.target.checked;
                chartRenderer.draw();
            });
            
            // ç¼©æ”¾æ§åˆ¶
            const zoomSlider = document.getElementById('zoom-slider');
            const zoomVal = document.getElementById('zoom-value');
            zoomSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                appState.chartState.zoom = val;
                zoomVal.innerText = val + 'x';
                chartRenderer.draw();
            });

            // æ£€æµ‹æ§åˆ¶
            document.getElementById('start-btn').addEventListener('click', () => handleControl('start_detection'));
            document.getElementById('stop-btn').addEventListener('click', () => handleControl('stop_detection'));
            document.getElementById('pause-btn').addEventListener('click', () => handleControl('pause_detection'));
            document.getElementById('resume-btn').addEventListener('click', () => handleControl('resume_detection'));

            // ROIè®¾ç½®æ§åˆ¶
            const roiInputs = ['roi-x1', 'roi-y1', 'roi-x2', 'roi-y2'];
            roiInputs.forEach(id => {
                document.getElementById(id).addEventListener('input', updateRoiDisplay);
                // æ·»åŠ é…ç½®è‡ªåŠ¨ä¿å­˜
                document.getElementById(id).addEventListener('change', () => {
                    console.log('ROI configuration changed, auto-saving...');
                    saveConfiguration();
                });
            });

            document.getElementById('apply-roi-btn').addEventListener('click', applyRoiConfig);

            // ROIå¸§ç‡æ§åˆ¶
            document.getElementById('roi-frame-rate').addEventListener('input', updateRoiFrameRateDisplay);
            document.getElementById('roi-frame-rate').addEventListener('change', applyRoiFrameRate);
            // æ·»åŠ å¸§ç‡é…ç½®è‡ªåŠ¨ä¿å­˜
            document.getElementById('roi-frame-rate').addEventListener('change', () => {
                console.log('ROI frame rate changed, auto-saving...');
                saveConfiguration();
            });

            // æ³¢å³°æ£€æµ‹é…ç½®æ§åˆ¶
            document.getElementById('apply-peak-config-btn').addEventListener('click', applyPeakDetectionConfig);

            // æ·»åŠ æ³¢å³°æ£€æµ‹é…ç½®å®æ—¶åŒæ­¥å’Œè‡ªåŠ¨ä¿å­˜
            const peakInputs = ['peak-threshold', 'peak-margin-frames', 'peak-difference-threshold', 'peak-min-region-length'];

            // é˜²æŠ–å‡½æ•°ï¼Œé¿å…é¢‘ç¹APIè°ƒç”¨
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // å®æ—¶åŒæ­¥é˜ˆå€¼å’Œè¾¹ç•Œæ‰©å±•å‚æ•°åˆ°åç«¯
            const syncThresholdParameters = debounce(async () => {
                try {
                    const threshold = parseFloat(document.getElementById('peak-threshold').value) || 105.0;
                    const marginFrames = parseInt(document.getElementById('peak-margin-frames').value) || 5;

                    // åŸºæœ¬éªŒè¯
                    if (threshold < 50.0 || threshold > 255.0 || marginFrames < 1 || marginFrames > 20) {
                        console.warn('Invalid parameters, skipping sync:', { threshold, marginFrames });
                        return;
                    }

                    // å‘é€åˆ°åç«¯
                    const config = {
                        threshold: threshold,
                        margin_frames: marginFrames
                    };

                    console.log('Syncing threshold parameters to backend:', config);
                    const response = await ApiService.setPeakDetectionConfig(config);
                    if (response && response.success) {
                        console.log('Threshold parameters synced successfully');
                    }
                } catch (error) {
                    console.error('Failed to sync threshold parameters:', error);
                }
            }, 500); // 500msé˜²æŠ–

            peakInputs.forEach(id => {
                // ä¸ºé˜ˆå€¼å’Œè¾¹ç•Œæ‰©å±•æ·»åŠ å®æ—¶inputäº‹ä»¶ç›‘å¬
                if (id === 'peak-threshold' || id === 'peak-margin-frames') {
                    document.getElementById(id).addEventListener('input', () => {
                        console.log(`Real-time parameter change: ${id}`);
                        syncThresholdParameters();
                    });
                }

                // ä¿æŒåŸæœ‰çš„changeäº‹ä»¶ç›‘å¬ç”¨äºæœ¬åœ°ä¿å­˜
                document.getElementById(id).addEventListener('change', () => {
                    console.log('Peak detection configuration changed, auto-saving...');
                    saveConfiguration();
                });
            });

            // è‡ªåŠ¨åŠ è½½ä¿å­˜çš„é…ç½®
            const hasSavedConfig = applySavedConfigToUI();

            // å¦‚æœæœ‰ä¿å­˜çš„é…ç½®ï¼Œå»¶è¿Ÿè‡ªåŠ¨åº”ç”¨
            if (hasSavedConfig) {
                setTimeout(() => {
                    // è‡ªåŠ¨åº”ç”¨ROIé…ç½®
                    const roiX1 = parseInt(document.getElementById('roi-x1').value);
                    const roiY1 = parseInt(document.getElementById('roi-y1').value);
                    const roiX2 = parseInt(document.getElementById('roi-x2').value);
                    const roiY2 = parseInt(document.getElementById('roi-y2').value);

                    if (roiX1 > 0 || roiY1 > 0 || roiX2 > 0 || roiY2 > 0) {
                        console.log('Auto-applying saved ROI configuration...');
                        applyRoiConfig().catch(error => {
                            console.warn('Failed to auto-apply ROI config:', error);
                        });
                    }

                    // è‡ªåŠ¨åº”ç”¨æ³¢å³°æ£€æµ‹é…ç½®
                    const threshold = parseFloat(document.getElementById('peak-threshold').value);
                    if (threshold > 0) {
                        console.log('Auto-applying saved peak detection configuration...');
                        applyPeakDetectionConfig().catch(error => {
                            console.warn('Failed to auto-apply peak detection config:', error);
                        });
                    }
                }, 2000); // å»¶è¿Ÿ2ç§’è®©ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ
            }

            // å¯åŠ¨
            initConnection();
        });

    </script>
</body>
</html>
