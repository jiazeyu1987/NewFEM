# 【开始检测】按钮逻辑文档

## 概述
【开始检测】按钮用于启动NewFEM系统的实时数据采集和波峰检测功能，是整个HEM（High-Echoic Events）检测系统的核心控制按钮。

## 前端逻辑

### UI元素
- **按钮位置**: `fronted/index.html` 第390行
- **按钮ID**: `start-btn`
- **按钮文本**: "开始检测"
- **绑定事件**: `handleControl('start_detection')` 函数

### 前端处理流程

#### 1. 事件处理入口
```javascript
document.getElementById('start-btn').addEventListener('click', () => handleControl('start_detection'));
```

#### 2. 控制处理函数
```javascript
async function handleControl(action) {
    // 主要处理逻辑在start-detection分支中
}
```

#### 3. 开始检测前置条件检查
```javascript
// 检查ROI配置状态（仅对开始检测）
if (action === 'start_detection') {
    if (!appState.roiConfigured) {
        alert('请先配置ROI区域后再开始检测！');
        return;
    }
}
```

#### 4. API调用
```javascript
const response = await ApiService.sendControl(action);
```

#### 5. 响应处理和状态更新
```javascript
if (response.status === 'success') {
    // 更新应用状态
    appState.connected = true;
    appState.detectionState = 'running';

    // 启动数据采集（通过轮询机制）
    updatePollingInterval();

    // 更新UI状态
    updateUI();
} else {
    // 失败回滚状态
    appState.detectionState = 'stopped';
    alert(response.message || '启动检测失败');
}
```

#### 6. 数据采集启动（轮询机制）
```javascript
function updatePollingInterval() {
    // 根据ROI帧率设置轮询间隔
    const roiFrameRate = appState.roiFrameRate || 2;
    const pollingInterval = Math.floor(1000 / roiFrameRate);

    // 启动实时数据轮询
    requestRealtimeData();
}
```

## 后端逻辑

### API端点
- **路径**: `POST /control`
- **文件位置**: `backends/app/api/routes.py`
- **处理器**: `execute_control()` 函数

### 后端处理流程

#### 1. 请求参数解析
```python
@router.post("/control", response_model=ControlCommandResponse)
async def execute_control(
    command: str = Form(...),
    password: str = Form(...),
) -> ControlCommandResponse:
```

#### 2. 密码验证
```python
verify_password(password)  # 验证管理密码
```

#### 3. 命令验证
```python
valid_commands = [
    "start_detection",
    "stop_detection",
    "pause_detection",
    "resume_detection"
]
if command not in valid_commands:
    raise HTTPException(status_code=400, detail="Invalid command")
```

#### 4. ROI配置检查（开始检测前置条件）
```python
cmd_lower = command.lower()
if cmd_lower == "start_detection":
    # 检查ROI是否已配置
    if not data_store.is_roi_configured():
        raise HTTPException(status_code=400, detail="ROI_NOT_CONFIGURED")
```

#### 5. 开始检测命令处理
```python
if cmd_lower == "start_detection":
    # 启动数据处理器
    if not processor.is_running():
        processor.start()
        logger.info("✅ Data processor started successfully")
        message = "检测已启动"
    else:
        message = "检测已在运行中"
```

## 数据处理器启动流程

### 处理器类
- **类名**: `DataProcessor`
- **文件位置**: `backends/app/core/processor.py`
- **单例实例**: `processor = DataProcessor()`

### 启动方法
```python
def start(self) -> None:
    if self._thread and self._thread.is_alive():
        self._logger.info("DataProcessor already running, start() ignored")
        return

    self._stop_event.clear()
    data_store.set_status(SystemStatus.RUNNING)
    self._thread = threading.Thread(target=self._run, daemon=True)
    self._thread.start()
```

### 数据生成循环
```python
def _run(self) -> None:
    while not self._stop_event.is_set():
        # 生成模拟信号数据
        signal_value = self._generate_signal_value(t)

        # 执行波峰检测
        peak_signal = self._enhanced_detector.detect(signal_value)

        # 存储数据到data_store
        data_store.add_frame(value=signal_value, timestamp=now, peak_signal=peak_signal)

        # 控制采样频率（60 FPS）
        time.sleep(1.0 / settings.fps)
```

## 波峰检测集成

### 增强波峰检测器
- **类名**: `EnhancedPeakDetector`
- **文件位置**: `backends/app/core/enhanced_peak_detector.py`
- **配置来源**: JSON配置文件的peak_detection节点

### 检测器初始化
```python
class DataProcessor:
    def __init__(self) -> None:
        # 从JSON配置加载波峰检测参数
        peak_config = PeakDetectionConfig(
            threshold=settings.peak_threshold,           # 从JSON加载
            margin_frames=settings.peak_margin_frames,   # 从JSON加载
            difference_threshold=settings.peak_difference_threshold,  # 从JSON加载
            min_region_length=settings.peak_min_region_length         # 从JSON加载
        )
        self._enhanced_detector = EnhancedPeakDetector(peak_config)
```

### 实时检测逻辑
```python
# 在数据生成循环中执行
peak_signal = self._enhanced_detector.detect(signal_value)
```

## ROI数据集成

### ROI截图服务
- **类名**: `RoiCaptureService`
- **文件位置**: `backends/app/core/roi_capture.py`
- **配置来源**: JSON配置文件的roi_capture节点

### 服务初始化
```python
class RoiCaptureService:
    def __init__(self):
        from ..config import settings
        self._frame_rate = settings.roi_frame_rate        # 从JSON加载
        self._cache_interval = settings.roi_update_interval # 从JSON加载
```

### 实时ROI数据生成
- **触发频率**: 按roi_frame_rate配置（默认2 FPS）
- **数据类型**: 灰度值序列
- **存储位置**: data_store中的ROI数据区域

## 数据流程图

```
用户点击 → 前端验证 → API调用 → 后端处理 → 数据处理器启动 → 实时检测
    ↓           ↓          ↓         ↓           ↓             ↓
 开始检测   → ROI配置检查 → control端点 → 启动线程 → 信号生成 → 波峰检测
                                                    ↓           ↓
                                                  数据存储 → 前端显示
```

## 状态管理

### 前端状态
```javascript
const appState = {
    connected: false,        // 连接状态
    roiConfigured: false,    // ROI配置状态
    serverUrl: 'http://localhost:8421',
    chartData: [],          // 图表数据
    roiData: null,          // ROI数据
    peakConfig: null        // 波峰配置
};
```

### 后端状态
```python
# SystemStatus枚举
class SystemStatus(Enum):
    STOPPED = "stopped"      # 已停止
    RUNNING = "running"      # 运行中
    PAUSED = "paused"        # 已暂停

# 在data_store中维护状态
data_store.set_status(SystemStatus.RUNNING)
```

## 实时数据轮询

### 数据采集频率
- **主信号数据**: 20 FPS (每50ms一次)
- **ROI数据**: 按配置帧率 (默认2 FPS)
- **系统状态**: 每5秒一次

### 前端轮询逻辑
```javascript
function requestRealtimeData() {
    if (!appState.connected) return;

    ApiService.getRealtimeData()
        .then(data => {
            // 更新图表数据
            updateWaveformChart(data.timeSeries);

            // 继续轮询
            setTimeout(requestRealtimeData, 50);  // 20 FPS
        });
}

function requestRoiData() {
    if (!appState.connected) return;

    ApiService.getRealtimeData()  // 同一接口包含ROI数据
        .then(data => {
            // 更新ROI显示
            updateRoiDisplay(data.roi);

            // 继续轮询
            setTimeout(requestRoiData, 500);  // 2 FPS
        });
}
```

## 错误处理

### 前端错误
- **ROI未配置**: alert提示"请先配置ROI区域后再开始检测！"
- **API调用失败**: 显示具体错误信息
- **网络异常**: 停止数据采集，显示连接断开状态

### 后端错误
- **无效命令**: HTTP 400, "Invalid command"
- **密码错误**: HTTP 401, "密码错误"
- **处理器启动失败**: HTTP 500, 详细错误信息
- **线程已运行**: 返回"检测已在运行中"消息

## 日志记录

### 前端日志
```javascript
console.log('开始数据采集');
console.error('数据请求失败:', error);
```

### 后端日志
```python
logger.info("🎯 Start detection command received")
logger.info("✅ Data processor started successfully")
logger.info("📊 Starting real-time data generation at %d FPS", settings.fps)
```

### 处理器日志
```python
logger.info("DataProcessor initialized with enhanced peak detection")
logger.info(f"Peak detection config: threshold={threshold}, margin_frames={margin_frames}")
```

## 配置依赖

### 必需配置
- **ROI配置**: 必须先配置ROI区域才能开始检测
- **波峰检测参数**: 从JSON文件自动加载
- **服务器连接**: 需要与后端API正常通信

### 配置验证
```javascript
// ROI配置验证
if (!appState.roiConfigured) {
    alert('请先配置ROI区域后再开始检测！');
    return;
}
```

## 性能考虑

### 数据生成性能
- **采样率**: 60 FPS数据生成
- **内存使用**: 循环缓冲区（默认100个数据点）
- **CPU使用**: 波峰检测算法O(n)复杂度

### 网络传输性能
- **数据压缩**: 使用高效的数据序列化
- **传输频率**: 前端轮询频率优化
- **带宽控制**: 限制单次传输数据量

### 前端渲染性能
- **Canvas渲染**: 高性能的图表绘制
- **数据点限制**: 限制显示的数据点数量
- **动画优化**: 使用requestAnimationFrame优化

## 测试验证

### 功能测试
1. **ROI未配置测试**: 验证前置条件检查
2. **重复启动测试**: 验证"已在运行中"提示
3. **正常启动测试**: 验证完整启动流程
4. **错误处理测试**: 验证各种异常情况

### 性能测试
1. **长时间运行测试**: 验证内存稳定性
2. **高频率数据测试**: 验证CPU和内存使用
3. **网络延迟测试**: 验证轮询机制的鲁棒性
4. **并发访问测试**: 验证多客户端访问能力

## 总结
【开始检测】按钮实现了完整的系统启动流程，包括严格的前置条件检查、数据处理器启动、实时数据采集和波峰检测集成，确保了NewFEM系统的稳定运行和实时HEM事件检测能力。