# 【应用波峰配置】按钮逻辑文档

## 概述
【应用波峰配置】按钮用于设置波峰检测算法的核心参数，包括阈值、边界扩展、颜色分类阈值和最小区域长度。

## 前端逻辑

### UI元素
- **按钮位置**: `fronted/index.html` 第596行
- **按钮ID**: `apply-peak-config-btn`
- **绑定事件**: `applyPeakDetectionConfig` 函数

### 前端处理流程

#### 1. 用户输入获取
```javascript
const threshold = parseFloat(document.getElementById('peak-threshold').value) || 105.0;
const marginFrames = parseInt(document.getElementById('peak-margin-frames').value) || 5;
const differenceThreshold = parseFloat(document.getElementById('peak-difference-threshold').value) || 2.1;
const minRegionLength = parseInt(document.getElementById('peak-min-region-length').value) || 3;
```

#### 2. 输入验证
- **阈值验证**: 50.0 ≤ threshold ≤ 255.0
- **边界扩展验证**: 1 ≤ margin_frames ≤ 20
- **颜色分类阈值验证**: 0.1 ≤ difference_threshold ≤ 10.0
- **最小区域长度验证**: 1 ≤ min_region_length ≤ 20

#### 3. 验证失败处理
- 验证失败时在console输出警告信息
- 使用 `console.warn()` 记录超出范围的参数
- 终止函数执行，不发送API请求

#### 4. API调用
```javascript
const response = await ApiService.setPeakDetectionConfig(
    threshold,           // 绝对阈值
    marginFrames,        // 边界扩展帧数
    differenceThreshold, // 颜色分类阈值
    minRegionLength      // 最小区域长度
);
```

#### 5. 响应处理
- **配置成功**: 更新本地状态并记录日志
  ```javascript
  appState.peakConfig = {
      threshold: threshold,
      margin_frames: marginFrames,
      difference_threshold: differenceThreshold,
      min_region_length: minRegionLength
  };
  ```
- **配置失败**: 显示alert弹窗提示错误
- **日志记录**: `console.log('波峰检测配置已保存到服务器JSON文件:', response);`

## 后端逻辑

### API端点
- **路径**: `POST /peak-detection/config`
- **文件位置**: `backends/app/api/routes.py` 第724行
- **处理器**: `set_peak_detection_config()`
- **响应模型**: `PeakDetectionConfigResponse`

### 后端处理流程

#### 1. 参数解析和验证
```python
threshold: Optional[float] = Form(None)
margin_frames: Optional[int] = Form(None)
difference_threshold: Optional[float] = Form(None)
min_region_length: Optional[int] = Form(None)
```

#### 2. 参数验证
- **阈值**: 50.0 ≤ threshold ≤ 255.0
- **边界扩展**: 1 ≤ margin_frames ≤ 20
- **颜色分类**: 0.1 ≤ difference_threshold ≤ 10.0
- **最小区域**: 1 ≤ min_region_length ≤ 20

#### 3. 错误响应处理
验证失败时返回详细错误信息:
```python
error = ErrorResponse(
    timestamp=datetime.utcnow(),
    error_code="INVALID_THRESHOLD",
    error_message="Threshold must be between 50.0 and 255.0",
    details=ErrorDetails(
        parameter="threshold",
        value=threshold,
        constraint="Range: 50.0-255.0"
    )
)
```

#### 4. JSON配置文件保存
```python
from ..core.config_manager import get_config_manager
config_manager = get_config_manager()

updates = {
    "threshold": threshold,
    "margin_frames": marginFrames,
    "difference_threshold": differenceThreshold,
    "min_region_length": minRegionLength
}

success = config_manager.update_config(updates, section="peak_detection")
config_manager.save_config()
```

#### 5. 运行时配置更新
- 更新settings对象保持兼容性
- 更新处理器的波峰检测配置
```python
if hasattr(processor, '_enhanced_detector'):
    new_config = PeakDetectionConfig(...)
    processor._enhanced_detector.update_config(new_config)
```

## JSON配置存储

### 配置文件结构
```json
{
  "peak_detection": {
    "threshold": 105.0,
    "margin_frames": 5,
    "difference_threshold": 2.1,
    "min_region_length": 3
  }
}
```

### 配置文件位置
- **文件**: `backends/app/fem_config.json`
- **节点**: `peak_detection`
- **管理器**: `config_manager.py`

## 波峰检测算法集成

### 算法参数说明
- **threshold**: 绝对灰度阈值，超过此值的区域进入波峰检测
- **margin_frames**: 边界扩展帧数，波峰区域前后扩展的帧数
- **difference_threshold**: 颜色分类阈值，用于区分绿色/红色波峰
- **min_region_length**: 最小波峰区域长度，过滤掉过小的波峰

### 实时应用
配置更新后立即应用到运行中的检测器:
```python
# backends/app/core/processor.py
self._enhanced_detector.update_config(new_peak_config)
```

### 算法执行流程
1. **数据输入**: 时间序列灰度值数组
2. **阈值检测**: 识别超过绝对阈值的区域
3. **边界扩展**: 按margin_frames扩展波峰边界
4. **颜色分类**: 根据frameDifference分类为绿色/红色波峰
5. **结果输出**: 绿色波峰列表和红色波峰列表

## 配置管理器集成

### 配置加载
应用启动时从JSON文件加载配置:
```python
# backends/app/config.py
def _convert_json_to_kwargs(self, json_config: dict) -> dict:
    if "peak_detection" in json_config:
        peak_config = json_config["peak_detection"]
        kwargs["peak_threshold"] = peak_config.get("threshold", 105.0)
        kwargs["peak_margin_frames"] = peak_config.get("margin_frames", 5)
        # ...
```

### 配置重载
处理器支持运行时配置重载:
```python
def reload_peak_detection_config(self) -> bool:
    new_settings = AppConfig.reload_from_json()
    new_peak_config = PeakDetectionConfig(...)
    self._enhanced_detector.update_config(new_peak_config)
```

## 数据流程

```
用户输入 → 前端验证 → API调用 → 后端验证 → JSON文件保存 → 算法配置更新
     ↓              ↓           ↓           ↓           ↓           ↓
   波峰参数      → 控制台警告  → 单个请求  → 错误响应  → peak_detection → 检测器
```

## 错误处理

### 前端错误
- **参数范围错误**: console.warn记录，不发送请求
- **API调用失败**: alert弹窗显示错误信息
- **网络异常**: console.error记录详细信息

### 后端错误
- **参数验证失败**: HTTP 400 + 详细错误信息
- **JSON保存失败**: HTTP 500 + 错误详情
- **检测器更新失败**: 错误日志记录但不影响保存

## 日志记录

### 前端日志
```javascript
console.warn('绝对阈值超出范围：', threshold);
console.warn('边界扩展帧数超出范围：', marginFrames);
console.log('波峰检测配置已保存到服务器JSON文件:', response);
```

### 后端日志
```python
logger.info("🔧 Peak detection configuration update requested")
logger.info("✅ Peak detection config saved to JSON file: %s", updates_str)
logger.info("🔧 Enhanced peak detector configuration updated: %s", updates_str)
```

### 算法调试日志
```python
# backends/app/peak_detection.py
print(f"DEBUG detect_peaks 调用参数:")
print(f"  threshold: {threshold}")
print(f"  marginFrames: {marginFrames}")
print(f"  differenceThreshold: {differenceThreshold}")
```

## 配置影响分析

### 算法敏感度
- **阈值增加**: 检测到的波峰数量减少，只检测更显著的峰值
- **margin_frames增加**: 波峰区域扩大，可能合并相邻的小波峰
- **difference_threshold增加**: 更多波峰被分类为红色（不稳定）
- **min_region_length增加**: 过滤掉持续时间短的波峰

### 实时影响
配置更新后:
1. **立即生效**: 新的ROI数据将使用新参数检测
2. **历史数据**: 已检测的历史数据保持不变
3. **界面更新**: 波峰指示器实时反映新检测结果

## 测试验证

### 功能测试
1. **参数边界测试**: 测试各参数的最小值和最大值
2. **无效参数测试**: 验证前端验证和错误处理
3. **JSON持久化测试**: 重启后验证配置保持
4. **算法影响测试**: 验证参数变化对检测结果的影响

### 集成测试
1. **端到端测试**: 从UI输入到JSON保存的完整流程
2. **实时性测试**: 配置更新后立即验证检测结果
3. **并发测试**: 多次配置更新的处理能力
4. **兼容性测试**: 与现有ROI检测流程的兼容性

## 性能考虑

### 配置更新性能
- JSON文件写入: 毫秒级操作
- 算法配置更新: 微秒级内存操作
- 不影响实时数据采集性能

### 算法性能
- 参数变化主要影响检测结果数量
- 计算复杂度保持O(n)不变
- 内存使用量稳定

## 总结
【应用波峰配置】按钮实现了完整的波峰检测参数管理，包括严格的参数验证、JSON文件持久化、实时算法配置更新和详细的错误处理机制，确保了波峰检测算法的灵活性和可靠性。